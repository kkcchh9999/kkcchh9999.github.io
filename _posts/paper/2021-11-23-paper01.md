---
title:  "I/O Stack Optimization for Smartphones 번역"
excerpt: "스마트폰을 위한 I/O 스택 최적화 논문 번역"
categories:
  - Papers
tags:
  - [android, papers]
toc: true
toc_sticky: true
sidebar: 
  nav: "docs"
---

## 논문 번역 
NOSLab 인턴 활동 기간동안 읽은 논문을 번역했다. 저작권을 염려하여 그림은 삽입하지 않았다.  
원 논문은 [https://www.usenix.org/conference/atc13/technical-sessions/presentation/jeong](https://www.usenix.org/conference/atc13/technical-sessions/presentation/jeong) 에서 찾아볼 수 있다. 저자는 Sooman Jeong, Hanyang University; Kisung Lee, Samsung Electronics; Seongjin Lee, Hanyang University; Seoungbum Son, Samsung Electronics; Youjip Won, Hanyang University 이다.

# I/O Stack Optimization for Smartphones

## 요약 :
Android 입출력 스택은 통합 행동이 잘 어우러지지 않은 정교하고 성숙한 구성요소로 이루어 져 있어 개선의 여지가 남아있다. 
우리는 SQLite 의 5가지 저널링 모드 각각에서 5개의 파일 시스템의 블록 I/O 동작을 검사했다. 
우리는 파일시스템이 데이터베이스의 저널링 활동을 저널하는 현상이 가장 큰 비효율의 원인이라는 점을 발견했다. 
이 현상을 우리는 JOJ 어노말리(변칙) 라고 부르기로 했다. EXT4 에서 부피가 큰 EXT4 저널링 활동이 SQLite 의 fsync() 명령으로부터 유발될 때 JOJ 오버헤드는 악화된다. 
SQLite 환경에서 파일시스템의 저널링 효율을 향상시키기 위해 파일시스템에서 불필요한 메타데이터 저널링 제거, 외부적 저널링 그리고 폴링 베이스의 입출력을 제안한다. 
우리는 5개의 데이터베이스와 3개의 최적화 기법의 각 조합에 대한 성능 trade-offs 을 조사했다.
우리가 기존의 Android IO 스택에 세개의 최적화 기술을 적용했을 때, SQLite 의 퍼포먼스(입력/sec)가 130% 증가했다. 
F2FS 파일시스템, WAL 저널링 모드(SQLite), 그리고 최적화를 위한 우리의 노력의 조합으로, 우리는 기존의 Android I/O 스택에 비해 SQlite 퍼포먼스를  39 ins/sec 에서 157 inc/sec 로 300% 향상시켰다.  


## 1. 도입 
스마트 기기, 예를들어 스마트폰, 테블릿, 스마트 TV 등은 대세 컴퓨팅 기기가 되었고, 그것들의 전임자 PC의 자리를 빠르게 대체하고 있다.
스마트폰과 태블릿은 DRAM 소비의 주축이 되었고, 웹 브라우징의 45%를 차지한다. 그들은 SNS, 게임, 카메라, 캠코더, mp3, 웹 브라우저를 포함하는 다양한 어플리케이션을 위한 개인용 컴퓨터가 되고있다.    

스마트폰의 성능은 와이파이 등의 에어링크의 속도로 결정되지 않는 대신, 상당히 비효율적인 방식으로 활용되는 스토리지 성능에 좌우된다. 
게다가, 이 비효율의 주요 원인 중 하나는 EXT4 저널링과 SQLite 저널링 사이의 조정되지 않은 과도한 입출력으로 부터 발생한다.
I/O 서브시스템은 전반적인 스마트폰의 성능에 미치는 영향이 크지만, 엔터프라이즈 서버, 웹 서버, OLTP 서버, 데스크탑 PC 만큼 철저하게 연구되지 않았다.    

이 연구에서 우리는 Android I/O 동작을 이해하기 위한 광범위한 측정 결과를 제시하고, 개별 계층을 최적화하여 계층이 통합될 때 전체 Android I/O 스택이 훨씬 더 효율적으로 동작하도록 하는 기술을 제안한다. Android I/O 스택은 수년간 개발되고 개선되어온 정교하고 성숙한 계층들(SQLite, EXT4, the interrupt-driven I/O of the Linux kernel, NAND-based storage)의 집합체이다. 계층들이 통합될 때, 통합 I/O 는 잘 조정되지 않고, 상당한 개선 여지를 남긴다. 우리는 Android 플랫폼의 DBMS 로부터 장치 스토리지로 가는 I/O 를 검사하고, 성능 향상을 위한 기술을 몇개 제안한다.   

우리의 기여는 다음과 같다 : 
- EXT4를 시작으로, 최신 Android 기반 스마트폰 중 하나에서 다섯개의 파일 시스템(BTRFS, XFX, NILFS, F2FS)에 대한 광범위한 성능 연구와 그들이 SQLite의 각 저널링 모드와 어떻게 상호작용하는지 조사했다. SQLite 저널링이 EXT4 저널링 계층과 예기치 않은 방식으로 상호작용하고, EXT4 파일시스템이 저장 장치에 이전에 보기 드문 방식으로 스트레스를 가한다. 우리는 최근에 소개된 F2FS가 Android I/O 스택이 저널링을 저널링하는 역설을 해결할 수 있는 좋은 방법이 될 수 있다는걸 알아냈다.  
- SQLite의 5가지 저널 모드를 시험하면서, Write-Ahead-Logging mode(WAL)이 5가지 중 가장 적은 양의 Synchronose random writes를 발생시킨다는 사실을 알아냈다.  
- 파일 시스템 저널 파일 액세스로 유도된 액세스 지역성을 명시적으로 보존하기 위해 파일 시스템 저널이 별도의 저장 장치에 유지되는 외부 저널링을 사용할 것을 제안한다. 이 접근 방식을 사용하면 NAND 스토리지의 FTL 레이어가 들어오는 I/O 스트림의 지역성을 보다 효과적으로 활용할 수 있고, NAND 플래시 관리 오버헤드를 줄일 수 있다. 
- NAND를 기반으로 하는 스토리지는 충분히 빠르고, 최첨단 스마트폰은 충분한 수의 CPU 코어를 갖추었다. 우리는 Android 저장 장치를 위한 polling 기반의 입출력 시스템을 개발했고, 그것의 유효성을 공부했다.

SQLite의 데이터베이스 저널링 모드와 파일시스템을 위한 최적의 선택의 혼합으로 (다시말해F2Fs, WAL 저널링 모드(in SQLite), 외부 저널링, 불필요한 메타데이터 커밋을 제거하는것, 폴링 기반 I/O), 기존의 Android에서 사용하는 SQLite의 성능과(입력/시간) 비교해 300%의 향상을 이루었다.   

이 논문의 나머지는 다음과 같이 편성되어 있다 :  

- Section2 배경 제시
- Section3 Android I/O 의 특성
- Section4 Android I/O 스택 조사
- Section5 다양한 Android filesystem에 대한 탐구
- Section6 Android I/O 스택의 최적화 기술
- Section7 통합 목표에 대한 결과 발표
- Section8 연구와 관련된 다른 기타 작업 설명
- Section9 결론

## 2. 배경
### 2.1 Android I/O stack
Android는 모바일 장치를 위해 디자인된 리눅스 기반의 오픈소스 운영체제이다. 그림 1은 Android 아키텍처를 보여준다. Android는 Java로 쓰여지고, .apk(Android Application Packages) 파일로 패키지되어 있다. Android는 다양한 시스템 구성요소 및 어플리케이션에서 광범위하게 사용되는 라이브러리 집합을 제공한다;  가장 널리 사용되는 라이브러리중에는 SQLite, libc(표준 C 라이브러리), 미디어 라이브러리가 있다. 리눅스 커널은 메모리 관리, 프로세스 관리, 보안, 네트워킹, 드라이버 모델 같은 핵심 기능을 제공한다. Android는 Dalvic 가상머신과 JIT 컴파일(Just-In-Time compilation = dynamic translation = 프로그램을 실행하는 시점에 기계어로 번역하는 컴파일 기법)을 .dex(Dalvic Executable) 파일들을 실행하기 위해 사용하고, 어플리케이션은 Dalvic VM의 위에서 실행된다.  

우리는 Android I/O 스택을 영구 데이터 관리를 위한 어플리케이션에 사용되는 하드웨어 계층과 소프트웨어의 집합이라고 정의한다. Android 입출력 스택은 DBMS(데이터베이스 관리 시스템), 파일시스템, block device driver, 그리고 NAND 플래시를 기반으로한 저장 장치로 이루어져 있다. SQLite와 EXT4는 각각 기본 DBMS와 파일시스템이다. Android 플랫폼은 인터럽트로 구동되는 I/O와 CFQ I/O 스케줄링 체계를 사용한다. eMMC 와 SD카드는 각각 내부, 외부 저장장치로 사용된다.   

대부분의 Android 어플리케이션은 지속적인 데이터 관리를 위해 SQLite 를 사용한다. SQLite 는 내부 파일시스템과 open(), unlink(), wirte(), fsync() 와 같은 시스템 콜로 상호작용한다. SQLite는 피해를 수복하기 위해 저널링을 사용한다. 이는 롤백 정보로 .db-journal 파일에 기록된다. 데이터베이스 파일과 저널 파일은 저장 장치에서 fsync()를 사용해 빈번하게 동기화된다.  

Android 4.0.4(Ice Cream Sandwich)버전부터, Android는 내부 스토리지 eMMC를 관리하기 위해 오직 EXT4만 사용한다.  

### 2.2 AndroStep: Android Storage Analzer
우리는 이 연구에서 분석, 수집, 재생을 위해 AndroStep을 사용했다. AndroStep은 Android 저장 스택의 행동을 분석하기 위해 개발된 도구 모음이다. 이는 Mobibench, MOST, Mobigen 으로 이루어져 있다. Mobibench(mobile benchmark)는 Android I/O 작업 생성을 위해 특별히  디자인된 워크로드 제너레이터이다. 이는 SQLite 워크로드(insert, update, and delete)와 파일시스템 워크로드(read, write, create, unlink 등등)을 발생시킬 수 있다. 유저는 SQLite 저널링 옵션, 파일시스템 저널링 절차, 다양한 파일시스템 입출력 옵션(예를 들어 직접 vs 버퍼I/O, 동기화 I/O 기타등등)을 설정할 수 있다. Mobibench 의 정확성은 널리 사용되는 벤치마크 IOZONE으로 검증됨.  

MOST(mobile storage analyzer)은 블록 레벨의 기록을 수집하고 분석하는 도구이다. 블록 기록에서, MOST는 블록의 유형(메타데이터, 저널, 데이터)그리고 SQLite 저널/데이터베이스, apk 처럼 파일 형식을 식별할 수 있다. MOST의 가장 큰 특징은 파일을 삭제하기 위해 이 정보를 추적하는 것이다.  

Androstep 에는 MOST와 Mobibench에 더하여 시스템 콜 기록을 기록하고 재생할 수 있는 Mobigen(Mobile Workload Generator)을 포함한다. Mobigen은 유저가 특정 어플리케이션을 사용할 때 발생되는 시스템 콜을 수집하기 위해 사용된다. 시스템 콜 기록을 재생함으로써 Mobigen은 실제 사람의 개입 없이도 사람이 주도하는 I/O 활동을 재현할 수 있다.

## 3. Android 어플리케이션의 I/O 특성
이전 연구들은 Android I/O 특성에 대한 광범위한 연구를 수행했고, SQLite 작업에 의해 I/O의 상당한 부분이 생성된다는 것을 발견했다. 논문의 저자들은 대부분의 Android 플랫폼에서의 입출력은 SQLite 데이터베이스 작업과 관련됨을 알아냈다. 다른 논문의 저자들은 광범위한 I/O 특성화 연구를 진행했고, 대부분의 Android I/O는 SQLite와 EXT4 파일시스템 사이의 어긋난 상호작용으로 인한 동기식 랜덤 쓰기임을 알아냈다. 우리는 Facebook 과 Twitter 앱이 매우 인기있기 때문에, 두 어플리케이션의 I/O 를 분석했다. 이전의 연구에서 14개의 인기 Android 앱에 대한 연구와 잘 일치하고 유사한 특징을 보이기 때문에 우리는 페이스북과 트위터에 대해서만 분석의 결과를 제시한다.  

실험의 결과는 Galaxy S3에서 기반했다. 우리는 I/O 기록을 분석하고 수집하기 위해 MOST를 사용했다.그림 2는 그 결과이다. 바 상단에 적힌 숫자는 I/O 요청의 수를 나타낸다. 실험 결과 요약은 다음과 같다:   
- **_쓰기 요청의 90%는 SQLite와 저널이다._** 우리는 파일을 6가지의 카테고리로 분류했다 : 데이터베이스 파일(.db), 저널 파일(.db_journal),실행 가능 파일(.so, .apk, .dex), 리소스(.dat, .xml), 기타등등. 우리는 Facebook, Twitter 모두에서 SQLite와 저널 파일이 입출력의 약 90%를 차지하는것을 알아냈다.
- **_전체 쓰기의 30%는 EXT4 저널 블록이 차지한다._** 우리는 파일시스템의 블록을 세가지로 분류했다: 메타데이터, 저널, 데이터. 전체 쓰기의 10%와 30%는 각각 메타데이터와 저널이다.
- **_모든 쓰기에서 70%는 동기화이다._** 그림 2(c)는 버퍼와 동기화 쓰기의 수를 보여준다. 쓰기의 70%는 주로 SQLite에서 시작된 동기화이다.
- **_모든 쓰기의 75%는 랜덤이다._** 그림 2(d)는 쓰기 명령의 공간적인 특성을 보여준다. 일반적으로 랜덤 쓰기는 NAND 에서 불리하고, 퍼포먼스 저하의 원인으로 여겨진다.
- **_64%의 I/O 명령에는 크기가 4KB 미만인 데이터가 포함된다._** 그림  2(e)는 I/O의 크기 분포를 보여준다. 대다수의 I/O 요청(64%)은 4KB 이하의 크기를 가진다. 이것은 EXT4의 SQLite 때문인데, 모든 데이터베이스 테이블의 업데이트와 각각의 저널링 활동이 저장 장치와 동기화되기 때문이다.
- **_eMMC에서 발생한 인터럽트 요청은 전체 인터럽트의 18%를 차지한다._** 그림 2(F)는 각 장치 드라이버에서 요청하는 인터럽트를 보여준다. 우리는 eMMC가 평균적으로 전체 인터럽트 요청의 18%를 차지하는것을 알아냈다. 

## 4. Android I/O stack 분석 
이 장에서, 우리는 EXT4 파일시스템 저널링과 SQLite의 저널링을 실험한다. 우리는 SQLite 저널링 모드, 특히 SQLite의 저널링과 EXT4의 저널링이 둘 다 활성화된 경우 Android 스토리지 시스템이 어떻게 영향을 받는지에 중점을 둔다. 

### 4.1 Journaling in SQLite
SQLite는 Android 플랫폼에서 가장 인기있는 지속적인 데이터 관리 모듈이다. 심지어 멀티미디어 플레이어들도 스피커 볼륨 같은 설정을 저장하기 위해 SQLite를 사용한다. SQLite는 트랜잭션 기능을 제공하기 위해 저널링을 사용한다. SQLite에는 6개의 저널링 모드가 있다 : DELETE, TRUN-CATE(Android 4.0.4에서 기본값), PERSIST, MEMORY, write-ahead logging(WAL), OFF. 이 모드들 사이의 차이는 미묘하고 심오하다.     

DELETE 모드에서 SQLite가 트랜잭션을 시작할 때 저널 파일을 생성하고, 트랜잭션이 끝나면 삭제한다. 저널 파일이 생성된 뒤에 SQLite는 저널 레코드를 삽입하고 fsync()를 호출하여 저널 파일이 영구적이 되도록 한다.   

TURNCATE 모드에서 SQLite가 트랜잭션이 끝나면 연결을 해제하지 않고 저널 파일을 0으로 삭제한다. 이 삭제는 저널 파일 생성 및 삭제와 관련된 메타데이터(예: 디렉터리 블록 및 inode 비트맵)을 업데이트 해야 하는 부담을 덜어주기 위해 실행된다.    

PERSIST 모드는 저널링을 효과적으로 줄이기 위해 TURNCATE 모드보다  더 공격적인 접근법을 갖는다. PERSIST 모드에서 SQLite가 트랜잭션이 완료될 때 파일을 삭제하는 대신, 데이터베이스 저널을 0으로 채운다. 흥미롭게도, 저널파일에 새로운 기록을 할 때, PERSIST 모드는 존재하는 블록(0으로 채워진)을 사용하는 반면, TURNCATE 모드는 새로운 블록을 생성한다. 메타데이터가 파일시스템 저널에 기록되는 양은 PERSIST 모드가 TURNCATE 모드보다 적다.   

MEMORY 모드에서 저널 기록은 메모리에 보관된다. MEMORY 모드는 저널 레코드를 유지하기 위해 파일 시스템에 의존하지 않음으로 메모리 모드는 파일시스템에 기반한 저널 모드와는 다르게 변화를 일으키지 않는다.   

WAL 저널링 모드는 별도의 WAL 파일(.wal)을 생성하고, 데이터베이스 업데이트를 로그파일에 기록한다. .wal 파일이 지정된 한계 크기에 도달하면, 미해결 로그는 데이터베이스 파일(.db)에 기록된다. WAL 모드에서, I/O 명령은 시퀀셜 한 경향이 있다; 그러므로 이 모드는 NAND 플래시 메모리를 활용하기에 적합하다.   

OFF 저널링 모드는 저널링을 사용하지 않는 것이다.

### 4.2 EXT4 Journaling and fsync()
EXT4 는 오랜 시간동안 Android 플랫폼의 기본 파일시스템이었다. 효율을 위해서, EXT4 저널링은 다중 시스템 콜을 위해 _저널 트랜잭션_ 이라 불리는 하나의 유닛으로 로그 기록을 유지하고, 그리고 이것을 메모리의 로그 레코드가 파일시스템 저널에 커밋될때 사용한다. 일반적으로, EXT4의 저널링 오버헤드는 무시할 수 있는데, 왜냐하면 저널 트랜잭션이 많은 로그 레코드로 구성되고, 저널 트랜잭션은 EXT4의 저널 파일에 상대적으로 긴 간격(예: 5sec)으로 커밋되기 때문이다. 하지만 Android 플랫폼에서는, ETX4 저널링 오버헤드가 빈번한 fsync() 호출로 인해 상당히 커졌다. 4.3에서 볼 수 있듯 SQLite의 삽입 명령은 2msec 이내에 두번, 혹은 그 이상의 fsync()명령을 호출한다. 각각의 fsync() 호출은 각 파일에 대한 업데이트 인코어 메타데이터를 나타내는 매우 적은 수의 로그 레코드로 구성되는 저널 트랜잭션의 커밋을 유발한다. 따라서 EXT4의 저널링은 fsync()로 유발될 때 매우 비효율적이다.  

EXT4 저널링(ordered 모드)에서 fsync()의 효과를 물리적으로 검토하자. 우리는4KB 쓰기 뒤에 fsync()를 발생시겼다. 그림 3(a)가 결과를 나타낸다. oredred 모드에서, 파일시스템은 먼저 파일을 업데이트하고, 해당 파일 메타데이터를 파일 시스템 저널에 커밋한다. fsync()의 결과로 저장장치에는 3번의 쓰기 명령이 발생했다. LBA의 낮은 범위에서의 첫 쓰기는 데이터 업데이트다. 두 번째와 세 번째 쓰기는 파일시스템 저널에 업데이트된 메타데이터를 커밋하는것이었다; 저널 디스크립터 쓰기, 로그 기록 삽입, 저널 커밋 마크 쓰기. 그림 3(a)에서, 저널 디스크립터와 로그 기록은 하나의 쓰기 명령으로 쓰여졌다. 하나의 write() 시스템 콜은 파일 시스템 저널을 업데이트하는 두개의 추가 블록 쓰기 명령을 동반한다. 이 실험에서 저널링 오버헤드는 200%였다. 
fsync()는 추가 쓰기명령 만들기 뿐만 아니라, 워크로드의 지역성을 무너뜨린다. fsync()는 기본 트래픽에 더 많은 무작위성을 도입하는데, 빈번한 저널 커밋 때문이다; fsync()는 상당한 퍼포먼스와, NAND 스토리지의 수명을 저하한다.

### 4.3 Journaling of Journal: Interacion between SQLite and EXT4
이전의 연구는 SQLite와 EXT4간의 조정되지 않은 상호작용으로 인한 과도한 I/O에 대해 기록했지만, 자세한 메커니즘은 연구되지 않았다. 우리는 EXT4(ordered mode)와 SQLite가 일으키는 블록 레벨의 I/O 활동에 대해 깊이있는 분석을 진행했다. 이 실험에서, 어플리케이션은 SQLite 데이터베이스 테이블에 하나의 기록(100Byte)을 삽입했다. 연구의 포괄성을 위해 우리는 SQLite의 4가지의 저널링 모드를 실험했다: DELETE, TRUNCATE, PERSIST, WAL. 그림 4는 그 결과를 나타낸다. 우리는 I/O의 시간, 각각의 시작 LBA, 크기를 기록했다. 추가로, I/O가 지정된 파일을 특정했다.   

SQLite의 입력 명령은 주로 두가지 단계로 이루어진다: i)SQLite의 저널에 입력 명령을 기록하고, ii)기록을 실제 데이터베이스 테이블에 입력한다. SQLite는 결과를 영구적으로 보존하기 위해 각 단계의 끝에,fsync() 명령을 호출한다. 각 EXT4 파일시스템은 파일을 업데이트한다. 
각 fsync() 명령은 EXT4 파일시스템이 파일을(database journal or databse table) 업데이트하게 하고 메타데이터의 업데이트를 EXT4 저널에 기록한다.   

그림 4(a)의 DELETE 모드부터 시작하자. SQLite는 저널 파일(.db-journal)을 생성하고, 삽입 명령을 위해 저널 엔트리를 기록하고, fsync()를 호출한다. fsync() 명령에 따라 EXT4는 .db-journal 파일을 스토리지에 쓰고, .db-journal의 메타데이터가 업데이트됨을 EXT4 저널에 커밋한다. 그리고 나면, SQLite는 레코드를 데이터베이스 테이블에 삽입하고(.db), 레코드를 스토리지에 저장하기 위해 fsync()를 호출한다. fsync()가 다시 호출되면 첫번째 단계에서의 호출과 같은 작업을 반복한다. 마침내, SQLite는 저널 파일을 삭제하기 위해 unlink()를 호출한다. **_하나의 삽입 명령이 장치의 스토리지에서 9번의 I/O 명령을 초래했다._**  
SQLite의 세가지 저널링 모드 DELETE, TRUNCATE, PERSIST 사이의 차이는  SQLite가 데이터베이스 저널 파일(.db_journal)을 처리하는지에 있다. 이 차이점은 EXT4 저널에 커밋되는 메타데이터의 양에 영향을 미친다. SQLite가 저널 파일을 재사용 할 때(TURNCATE 모드), EXT4는 SQLite의 저널 파일을 생성하고 삭제하는데에서 생성되는 메타데이터 업데이트에 대한 커밋의 부담을 줄일 수 있다. PERSIST 모드에서는, SQLite의 저널 뿐 아니라 저널 파일의 데이터 블록까지 재사용한다. 따라서, SQLite가 PERSIST 모드에서 명령을 수행할 때, SQLite의 새로운 데이터 블록을 할당하는데서 관련된 메타데이터 업데이트에 대한 커밋의 부담을 더 줄일 수 있다. 그림 3의 실험 결과를 보자. 그림4(a), (b), (c) 의 각 파일 시스템에 저널에 지정된 첫 번째 명령은 SQLite 저널에 대한 업데이트된 메타데이터를 커밋하는 것이다. 이 명령의 크기는 DELETE, TRUNCATE, PERSIST 모드에서 각각 24KB, 16KB, 8KB이다.  

그러나 PERSIST 모드에서, SQLite 는 트랜젝션의 끝에서 추가적인 fsync()콜을 유발한다. 이는 SQlite 저널과 저장소의 0-채우기 명령에 대한 동기화를 위함이다. PERSIST모드는 네가지의 SQLite 저널 모드 중 가장 많은 수의 I/O명령(12번)을 유발한다.  

쓰기-우선 로깅(WAL)에서는, SQLite는 삽입하거나 업데이트하는 명령을 로그 파일에(.db-wal) 기록한 후에, fsync()를 호출한다. 그러면 EXT4 파일시스템은 wal 파일을 업데이트하고, 메타데이터 업데이트를 EXT4 저널에 커밋한다. 단 한번의 fsync() 호출만 하기 때문에, 파일시스템 저널링의 오버헤드가 가장 적고, SQLite의 다섯가지 저널링 모드 중에 WAL 모드에서 데이터베이스 명령의 효율이 가장 높다. 그림 4(d)는 WAL모드에서 입출력 트레이스를 보여준다. SQLite는 로그 파일에 로그의 순서를 유지해야 하기 때문에, WAL 모드는 저장공간을 가장 많이 소비한다.   

Android 플랫폼의 광범위한 분석과 함께, 우리는 EXT4파일시스템이 SQLite의 fsync()명령을 통해 _데이터베이스의 저널링을 저널하는것_ 을 관찰했다. 부피가 큰 EXT4의 저널링 메커니즘(4KB 로그 기록)은 SQLite 데이터베이스(.db)의 메타데이터와 SQLite의 저널(.db-journal)을 커밋한다. 결과적으로, SQLite에서 사용될 때, EXT4 파일은 과도한 양의 작은 쓰기를 생성한다 그리고 스트레스를 준다 저장소에 이전에는 거의 관찰되지 않은 방법으로 스트레스를 가한다. 파일시스템 저널링과 데이터베이스 저널링의 오버헤드는 명령들이 함께 사용될 때 합해진다. 우리는 이 현상을 JOJ(저널링의 저널링) 라고 부른다. 또한 우리는 어떠한 SQLite의 저널링 모드도 JOJ로 부터 자유롭지 않지만, WAL 모드가 파일시스템에 가장 적은 스트레스를 가한다는 점을 찾아냈다.   

가장 이상적이고 고전적인 JOJ의 해결책은 SQLite가 파일시스템의 도움 없이 직접 스토리지를 관리하거나, Android 어플리케이션이 SQLite 없이 직접 파일시스템을 사용하는 것이다. 이 접근은 SQLite stack의 정밀 검사나, 수많은 Android 어플리케이션 개발자들에게 어플리케이션을 만들 때 불편한 파일시스템을 사용하기를 요구한다.

## 5. Android의 대체 파일시스템
우리는 Android 플랫폼에서 행동을 분석하기 위해 네가지의 인기있는 파일시스템의 행동을 분석했다: BTRFS, NILFS2, XFS 그리고 가장 최근에 소개된 F2FS. 우리는 이 파일시스템들을 Galaxy S3에 이식했다. 우리는 이 파일시스템들의 블록레벨에서 I/O 행동패턴과 전반적인 성능을 실험했다.  

### 5.1 Details of Filesystem Behavior
BTRFS는 데이터와 메타데이터를 저장하기 위해 B+트리를 사용하고, 내용을 업데이트하기 위해 copy-to-write 방식을 채택한다. 파일시스템의 유망한 기능(e.g. 파일 하위 볼륨 스냅샷, 온라인 조각모음, SSD에 대한 TRIM 지원)에도 불구하고, B+트리, copy-to-write 이 두 가지 특성은 BTRFS를 안드로이드 플랫폼에서 최악의 파일시스템으로 만든다. BTRFS는 트리 노드의 업데이트가 트리의 루트에 대한 계단식 업데이트를 하게 되는 wandering tree problem을 겪고 있다. 그림 3(b)는 4KB 쓰기 뒤에 fsync()가 호출되었을 때의 I/O 행동패턴을 보여준다. fsync()가 발생하면, BTRFS는 최종적으로 4개의 B+트리를 기록하고, 슈퍼블록을 저장소에 동기화한다. 4KB 쓰기를 위해 fsync()가 호출되면 BTRFS는 다섯번의 추가적인 쓰기가 발생한다.  

NILFS2는 로그 구조의 파일시스템이다. 이는 데이터 쓰기 집합과 모든 업데이트된 메타데이터를 하나의 세그먼트로 병합하고, 저장소에 세그먼트를 동기화한다. NILFS2에서 이 세그먼트의 사이즈는 128KB이다. NILFS2에서 fsync()명령은 모든 논리적 세그먼트를 비우도록 설계되어 있다. 그림 3(c)는 4KB쓰기 이후의 fsync()에 대한 결과를 보여준다. 각 fsync()는 128KB의 쓰기를 유발한다. 로그 구조임에도 불구하고, NILFS는 큰 사이즈의 세그먼트와, 비효율적인 세그먼트 비우기 메커니즘으로 인해 로그 구조를 잘 활용하지 못한다.   

XFS는 대규모 엔터프라이즈 스토리지에서 고안된 저널링 파일시스템이다. 이는 최대 파일 크기를 8EByte(8 * 2^60)로, 저장소에서 저장할 수 있는 만큼 많은 파일을 처리할 수 있을 것으로 기대된다. XFS는 B+트리를 기반의 디렉토리 구조를 사용하고, 확장성을 위해 sparse file을 지원한다. XFS의 디자인 목표가 대규모 시스템임에도 불구하고, XFS는 쓰기 뒤의 fsync()에서 아주 좋은(2번째로 좋은) 퍼포먼스를 보여준다. 그림 3(d)은 XFS의 블록 접근 패턴을 보여준다. XFS의 퍼포먼스 이점은 다음 2가지에 의해 생긴다: 저널 쓰기의 수 그리고 각 저널 쓰기의 크기. fsync() 명령은 EXT4의 저널 쓰기 수의 절반에 해당하는 하나의 저널 쓰기를 발생시킨다. 게다가 EXT4의 저널 쓰기 크기는 최소 4KB인 반면, XFS는 1KB이다.   

F2FS는 우리가 연구한 5가지의 파일 시스템 중 가장 최근에 개발된 파일 시스템이다. 이는 플래시 메모리를 위해 특별히 디자인된 로그 구조의 파일 시스템이다. F2FS는 플래시 기반 저장소에서 가비지컬렉션의 오버헤드를 줄이기 위해 입력받는 쓰기 요청을 비슷한 특성끼리 분류한다. 이전까지 존재하던 로그 구조 파일시스템과 다르게, 파일 시스템을 업데이트하기 위해 대용량 쓰기에서 일련의 쓰기의 절차를 수집하고, 또한 F2FS는 스토리지에 작은 유닛(4KB)으로 업데이트 할 수 있다. 이 기능은 F2FS가 write() 뒤에 따라오는 fsync() 명령 같은 corner-case 워크로드에서 매우 효과적으로 작동하게 한다. 그림 3(e)는 F2FS의 I/O 트레이스를 나타낸다. 이는 두가지 쓰기를 가진다: 하나는 데이터를 위해, 하나는 inode를 위해. 다른 로그 구조 파일시스템인 NILFS2가 같은 상황에서 128KB의 쓰기를 갖는 반면에 F2FS의 쓰기 크기는 4KB이다.

### 5.2 Summary: write() Followed by fsync()   
우리는 전형적인 안드로이드 플랫폼에서의 워크로드에서 다섯개의 파일시스템의 퍼포먼스에 대해 비교한다: 4KB 쓰기에 이은 fsync(). 그림 5는 결과를 보여준다. XFS와 F2FS가 5개의 파일 시스템 중 최고의 성능을 낸다. F2FS는 랜덤 쓰기 퍼포먼스에서 최고 성능을 보여주고, XFS는 순차 쓰기에서 최고 성능을 보여준다. fsync()의 성능 관리의 주된 요인은 우리가 section 5.1에서 주의깊게 연구한 파일 시스템 저널링의 효율성이다. XFS에서, 로그 레코드의 크기는 1KB이고, 하나의 쓰기는 하나의 저널 커밋을 유발한다. EXT4에서, 로그 레코드의 크기는 4KB이고, 각 저널 커밋 명령에서 최소 2번의 쓰기를 유발한다. 랜덤 쓰기에서, XFS와 F2FS는 각각 EXT4보다 대략 50%, 70% 정도 나은 성능을 보여준다. BTRFS는 랜덤과 순차쓰기 모두에서 최악의 성능을 보여준다. section 6에서 우리는 각 파일시스템에서 SQLite 명령의 퍼포먼스가 4KB 쓰기에 이은 fsync()에서 증명된 퍼포먼스와 정확히 비례하는지 확인할 것이다. 

## 6. I/O stack의 최적화 
이 부분에서, 우리는 JOJ 현상으로부터 유발되는 비효율성을 개선하는 최적화 기술을 소개하고, 개별 기술의 성능 효과를 실험한다. 

### 6.1 Eliminating Unnecessary Metadata Flushes 
최적화를 위한 우리의 첫번째 노력은 SQLite의 fsync()로 유발되어 파일시스템 저널에 커밋되는 메타데이터의 양을 줄이는것이다. fsync() 명령은 메타데이터와 저장할 데이터 모두를 flush한다. 우리는 fdatasync() 명령이 fsync()명령의 훌륭한 대안임을 찾아냈는데 이 명령은 후속 데이터 검색이 올바르게 처리될 필요가 없으면 메타데이터를 비우지 않는다. 안드로이드 플랫폼의 파일시스템은 noatime 옵션이 탑재되어있고, SQLite는 파일 크기만 신경쓰며 다른 특성은 신경쓰지 않는다고 명시한다. 기본 OS 및 파일 시스템이 fdatasync를 올바르게 지원하도록 보장되므로 fdatasync를 사용해도 파일 시스템 무결성에 영향을 미치지 않는다.    

우리는 fsync()를 fdatasync()로 교체한 뒤, 5가지의 파일시스템을 사용해서SQLite 명령들의 퍼포먼스를 실험했다. 그림 6은 결과를 보여준다. X축의 B, F 그리고 E는 각각 기준선(fsync()만 해당), fdatasync() 확장 버전 그리고 외부 저널링이 있는 파일 시스템을 나타낸다. 외부 저널링에 관한  상세 사항은 section 6.3에서 다룬다. 

fdatasync()를 사용함으로써, 우리는 하나의 삽입 명령에서의 EXT4의 퍼포먼스를 17% 향상시켰다. 하나의 삽입 명령에 대하여 SQLite는 F2FS와 최고의 성능을 나타냈다. SQLite는 EXT4 보다 F2FS에서 111% 더 빠른 삽입 속도(insert/sec)를 보였다. BTRFS와 NILFS2에서는 fdatasync()를 사용하는 이점이 제한적이었다. 이는 BTRFS와 NILFS2에서 하나의 삽입 명령이 fdatasync()를 사용해도 메타데이터가 플러시되는 경우에 새로운 블록을 할당하기 때문이다. 그림 6(a)는 그 결과를 보여준다.    

fdatasync()를 사용하는 이점은 삽입 명령보다 업데이트 명령을 사용할 때 더 크게 작용한다. 그림 6(b)는 그 결과를 보여준다. 업데이트는 파일 시스템의 관점에서 기존 데이터 레코드를 덮어쓰기 하는 것이다. EXT4와 XFS에서, 업데이트명령은 파일 크기, 간접 블록, 사용 가능한 블록 비트맵과 기타 등등에서 어떠한 변화도 가져오지 않는다. 따라서 fsync()를 fdatasync()로 바꾸는것은 상당한 양의 메타데이터 비우기를 절약했다. EXT4와 XFS에서는 fsync()가 fdatasync()로 변경되면서 update/sec가 각각 50%, 66% 증가했다. 그에 반해서, copy-on-write 기반의 파일시스템 BTRFS, NILFS 에서는 fdatasync()가 약간의 상향만 유발했는데, 이는 업데이트 작업이 fdatasync()를 사용해도 플러시되는 새로운 블록을 할당하고 후속 메타데이터를 업데이트하기 때문이다. 업데이트 명령에서, F2FS가 5가지 파일시스템 중 가장 큰 퍼포먼스 향상을 나타냈다. F2FS가 fdatasync()와 함께 사용될 때, SQLite의 퍼포먼스는 기존(EXT4, fsync())보다250% 향상되었다.

### 6.2 Using the Optimal Journaling Mode in SQL
I/O 퍼포먼스는 DBMS의 저널링 모드에 매우 민감하다. 우리는 SQLite의 다섯가지의 저널링 모드(DELETE, TRUNCATE, PERSISTANT, WAL, OFF)를 다섯가지 파일시스템(EXT4, NILFS2, XFS, BTRFS, F2FS)에서  각각 실험했고, SQLite의 퍼포먼스를 측정했다(insert, update). 그림 7은 결과를 보여준다. 삽입 명령의 퍼포먼스는 DELETE, TRUNCATE, PERSIST를 사용했을 때에 저널을 off 했을 때 보다 50% 이상 감소했다. 모든 파일시스템에서 4가지 저널링 모드 중, WAL 모드는 최고의 insert/sec 퍼포먼스를 나타냈다(그림 7(a)).   

모든 파일시스템의 업데이트 명령에서 WAL 모드는 다른 저널링 모드들과 비교해 3배 이상의 퍼포먼스를 나타냈다(그림 7(b)). 공개적으로 사용 가능한 SQLite와 달리, Galaxy S3의 SQLite는 업데이트 명령에서 저널 파일을 생성하지 않는다. 이는 상당히 나은 퍼포먼스를 제공하지만, 업데이트 명령은 복구할 수 없다. 

삽입과 업데이트 명령에서, F2FS는 모든 저널링 모드에 대해 최고의 퍼포먼스를 내는 파일시스템이다. EXT4를 F2FS로 교체하면, SQLite의 퍼포먼스는 최소 67% 상승한다. 이는 EXT4가 저널 모드에 따라 3~12번의 랜덤 I/O를 유발하는데 반해, F2FS는 하나는 데이터를 위해, 또 다른 하나는 메타데이터를 위해, 오직 2번의 4KB I/O를 유발하기 때문이다. 모든 파일시스템에서, WAL 모드는 최고의 퍼포먼스를 보여주는데, 이는 모든 삽입과 업데이트 명령에서 생성되는 로그 데이터는 .db-wal 파일에 추가되고, 단 한번의 fsync()만 발생하기 때문이다. BTRFS는 삽입과 업데이트 명령에서 모두 최악의 퍼포먼스를 보여줬는데, 이는 wandering tree 현상 때문에 더 많은 write() 명령을 발생시키기 때문이다.   

요약하면, 안드로이드 플랫폼에서, 퍼포먼스 관점으로 보았을 때, WAL 모드는 최적의 저널링 모드이다. 성능적 이점이 있음에도, WAL은 몇몇 문제가 있는데, 공간 요구사항과, 복구 시간이다. 이들은 별도의 문맥에서 다룰 필요가 있다. 

### 6.3 External Journaling
EXT4와 XFS는 저널 블록을 분리된 블록 디바이스에 저장하는 옵션을 가지고 있다. 이 옵션은 External Journaling(외부 저널링)이라고 불린다. 우리는 외부 저널링이 트래픽에서 무작위성을 제거하고, 기본 NAND 스토리지가 트래픽의 지역성을 쉽게 이용할 수 있도록 동일한 스토리지 영역에 상관된 쓰기를 함께 클러스터링 하는 실행 가능한 옵션이 될 수 있음을 보여준다.   

그림 8에서, 우리는 EXT4 파일시스템의 4KB 랜덤 쓰기 이후의 fsync()로 부터의 I/O 트레이스를 구성한다. EXT4 저널 블록은 770 - 780M 인 반면, 데이터 파일은 1160 - 1170MB 범위이다. 우리는 전체 트레픽이 두개의 다른 I/O 스트림의 교차로 배치된 혼합물로 구성됨을 명백하게 볼 수 있다: 데이터 영역의 지역성은 무작위인 반면, 저널 영역은 순차적이다. 데이터와 저널의 I/O를 분리하는것은 NAND 기반 저장소의 FTL이 들어오는 I/O 스트림의 지역성을 쉽게 인식하고 활용할수 있게하는 다음 단계를 명백하게 나타낸다. 최근의 eMMC 인터페이스 표준은 내장 메모리의 물리적 파티셔닝을 허용한다. 따라서, 외부 저널링은 미래의 스마트폰 저장소에서 실용적인 선택이 될 수 있다.   

우리는 EXT4와 XFS에서 외부저널링의 효율성을 실험했다. 우리는 Transcend사의 16GB SD카트와 내부의 eMMC를 데이터 저장소와 외부 저널을 위해 각각 사용했다. 그림 6의 외부 저널을 위해 E가 존재하는 곳에서 그 결과를 보여준다. 외부 저널링은 EXT4에서 상당한 퍼포먼스 향상을 보여준다; 삽입은 30%, 업데이트는 39% 향상되었다. XFS에서의 향상은 EXT4에서의 향상보다 대단하지는 않았는데, 이는 XFS의 저널링 오버헤드가 EXT4에서만큼 크지 않기 때문이다.  

### 6.4 Polling-based I/O 
CPU 코어의 수를 늘리는것과, 블록 장치의 I/O 지연시간을 줄이는 것은 polling-based I/O 가치의 재발견으로 이끌었다. 최첨단 스마트폰은 쿼드코어 CPU를 가지며, NAND 기반 스토리지의 지연 시간은 기존 하드디스크 드라이브보다 짧다. 이런 환경에서 interrupt-driven I/O는 컨텍스트 스위치 때문에 시스템의 퍼포먼스를 방해한다. 많은 작은 I/O가 블록 I/O 레이어에서 생성되 때, eMMC의 I/O 데몬 mmcqd 는 상당한 컨텍스트 스위치 오버헤드를 받는다. 우리의 결과는 아래에서 폴링 기반 I/O가 전체 시스템 퍼포먼스를 희생하지 않고 인터럽트 기반 I/O 보다 우수한 I/O 퍼포먼스를 제공할 수 있음을 보여준다.   

우리는 안드로이드의 I/O 플랫폼의 mmcqd가 장치 스토리지에 접근하기 위해 폴링을 사용하도록 수정했다. 폴링기반 I/O에는 두가지 문제가 있다: CPU 독점, 전력 소모량. 우리는 폴링 기반 I/O가 진행중인 어플리케이션, 특히 CPU 집약적인 어플리케이션을 방해하는 경우 실험한다. 우리는 벤치마크 과정과 함께, HD 품질(1920 X 1080, 30fps)의 동영상 녹화 어플리케이션을 구동했다. 우리는 I/O 서브시스템이 폴링 방식으로 구동되는 경우에도, 비디오 녹화의 요구사항이 부드럽게 보존되고 있음을 발견했다. 우리는 폴링 기반 I/O 서브시스템의 전력 소모행위를 테스트하기 위해 다른 실험을 진행했다. 폴링 기반 I/O는 CPU 사이클을 더 많이 소모하고 CPU가 저전력 모드를 유지할 기회를 줄일 수 있다. 우리의 실험에 따르면, 폴링 기반 I/O에서 CPU 활용은 4% 증가했다. 스마트폰에서, 에너지 소모의 지배적인 부분은 LCD와 WiFi이다. 우리는 폴링기반 I/O의 전력 소모가 제한적이며, 따라서 폴링 기반 I/O 는 실현 불가능한 방법이 아니라고 조심스레 주장한다.   

그림 9는 기본과, 폴링기반 I/O에서 mmcqd 데몬이 만든 문맥 교환을 보여준다. 우리는 자발적 문맥교환이 1/100으로 줄고, 전체 문맥 교환은 1/50으로 줄어든 것을 관측했다.   

우리는 폴링기반 I/O와 기본 I/O의 I/O 퍼포먼스를 실험했다. 우리는 두 가지 실험을 진행했는데, 하나는 싱글스레드이고, 다른 하나는 10개의 스레드에서 진행했고, 각각의 스레드에서는 4KB 랜덤 쓰기 뒤에 fsync()를 실험했다. 우리는 10개의 스레드를 폴링기반 I/O가 빈번한 TLB miss에서 어떻게 동작하는지 시험하기 위해 만들었다. 표 1은 결과를 보여준다. 싱글 스레드의 경우, CPU가 idle 할 때 1,2%의 퍼포먼스 이득을 보여준다; 스마트폰이 백그라운드에서 HD 비디오를 녹화중일 때 폴링기반 I/O는 13%의 퍼포먼스 이익을 보여준다. 10개의 스레드를 구동할 때는, 성능 이득이 약간 더 적지만, 여전히 HD 비디오를 녹화중일 때 10.1%의 성능 이득을 보여준다. Yang 외 연구진들이 논의한 것 처럼, 성능은 더 빠른 저장 매체에서 더 많이 향상될 것이다.   

### 6.5 Replay of Real Workload
최적화의 효율을 검증하기 위해 마지막 단계에서 우리는 각 최적화 기술을 실제 워크로드에서 실험한다. 우리는 시스템 콜 트레이스를 모았고, Mobigen으로 재생했다. 우리는 안드로이드에서 널리 사용되는 어플리케이션에서 트레이스를 수집했다: Twitter, Facebook.   

Twitter, Facebook에서 수집한 I/O 트레이스를 재생면서, 우리는 두 어플리케이션에서 처리된 I/O 시간을 추출했다(그림 10). 이 연구의 결과는 SQLite의 퍼포먼스와 write() 뒤의 fsync() 퍼포먼스에서 얻은 결과와 유사한 특성을 보여줬다. 두 어플리케이션의 재생에서, F2FS가 최고의 퍼포먼스를 보여줬다.  

## 7 모든 개선사항의 혼합
우리는 세가지 파일시스템(EXT4(기본), XFS, F2FS)에서 앞서 언급한 세가지 기술을 혼합한 상태로 SQLite의 퍼포먼스를 실험했다. (외부 저널링은 F2FS이 로그 구조 파일시스템이라 적용할 수 없기 때문에) SQLite의 저널링 모드는 TRUNCATE(기본)로 설정했다.  
 
그림 11은 결과를 보여준다. 현재 기본 구성의 I/O 퍼포먼스는 39 insert/sec 그리고 102 update/sec 로 나타난다. fdatasync()와 외부 저널, 폴링 기반 I/O를 적용하면, EXT4에서 SQLite는 삽입, 업데이트 명령에서 각각 53%, 130%의 성능 이득을 보여준다. XFS와 F2FS는 더 커다란 성능 향상을 보여준다. F2Fs에서 fdatasync()를 사용하고, 폴링기반 I/O를 사용할 때 최고의 SQLite  퍼포먼스를 보여준다: 기본 구성과 비교했을 때, 삽입과 업데이트에서 각각 130%와 250%의 성능 개선을 보여준다.  

마침내, 우리는 제안된 모든 기능을 혼합했다. 우리는 WAL(write-ahead logging) SQLite 저널링 모드를 사용했고, SQLite의 퍼포먼스를 세 가지의 파일시스템에서 실험했다. 모든것을 적용하여(fdatasync(), 외부저널링, 폴링기반 I/O, WAL SQLite 저널모드) EXT4에서 150%의 SQLite성능 향상을 이루어 냈다(39 insert/sec -> 92 insert/sec). 안드로이드 I/O 스택에 EXT4대신 F2FS를 사용하고, 모든것을 적용시켜서, 우리는 놀랍게도 300%의 SQLite 성능 향상을 이루어 냈다(39 insert/sec -> 157 insert/sec). 표 2는 결과를 요약한다.  

## 8 관련 연구
스토리지 I/O의 특성은 다양한 컴퓨터 환경에서 널리 연구되었다. Ruemmler과 연구진은 다른 세가지 HP-UX 시스템에서디스크 I/O를 분석한 결과, I/O 명령의 주된 부분은 쓰기 명령이고, 쓰기 명령의 67-78%는 메타데이터를 위한 쓰기 명령이고, 모든 접근 중 유저 데이터 I/O는 3-41%임을 증명했다. Roselli와 연구진은 파일 엑세스가 쌍봉 분포를 따른다고 보고했다: 몇몇 파일은 읽는 과정 없이 반복적으로 쓰이는 반면, 몇몇 파일은 거의 독점적으로 읽힌다. Zhou와 연구진은 파일 시스템의 읽기/쓰기 비율이 80%/20%임을 찾아냈고, 대부분의 쓰기 I/O는 랜덤임을 밝혔다. Harter와 연구진은 Mac OS 파일시스템의 I/O 행동패턴을 연구했고, 파일의 순차 I/O는 복잡한 XML 기반의 문서 포멧 때문에 블록 장치에서 순차 I/O를 발생시키지 않음을 증명했다. Prabhakaran과 연구진은 저널링 파일시스템(EXT4, ReiserFS, JFS, NTFS)의 철저한 분석을 제공하고, 저널에 데이터와 메타데이터가 기록되게 하는 이벤트를 설명했다. Pierns와 연구진은 데이터에서 메타데이터를 분리하는 방법을 제안했고, 이 분리가 파일시스템의 퍼포먼스를 향상시킴을 증명했다.   

스마트폰에 관해 사용자 행동 분석에서 전력 소비, 보안, 스토리지 성능 측정에 이르기까지 다양한 흥미로운 연구가 존재한다. Kim과 연구진은 스마트폰에 관한 스토리지 대역폭이 네트워크 대역폭보다 높다는 통념이 재고되어야 함을 증명했다. 그들은 네트워크 대역폭이 상당히 증가했기 때문에, 스토리지 퍼포먼스가 실재로 어플리케이션과 OS의 퍼포먼스에 영향을 끼치는것을 증명했다. 그들은 NAND 스토리지 장치에서 더 나은 순차 접근을 제공하는 버퍼캐시 교체 구조를 제안했다. Lee와 연구진들은 11개의 스마트폰 어플리케이션에서의 I/O 행동패턴을 분석했고, SQLite 저널링과 EXT4 저널링 의 혼합으로 과도한 랜덤 쓰기 명령을 유발하는것을 찾아냈다. Min과 연구진은 NAND 기반 저장소에서 랜덤 쓰기의 오버헤드를 완하시키기 위해 로그구조 파일시스템에서 다중 랜덤 쓰기를 하나의 쓰기로 혼합하는 방법을 제시했다. 이 접근은 개별 랜덤 쓰기가 스토리지에 동기화된 안드로이드 플랫폼에서는 동작하지 않았다.  Yang과 연구진은 매우 낮은 지연시간의 차세대 비휘발성 메모리에서는 기존의 인터럽트 기반 I/O를 사용하는 것 보다 폴링을 사용하는것이 더 높은 퍼포먼스를 제공할 수 있음을 증명했다.  

## 9 결론 
현대의 OS들은 각 계층에서 독립된 명령을 보장하는 계층 구조를 가진다; 그러나, 기본 메커니즘을 무시하면 저장 장치와 관련된 상당한 오버헤드가 발생한다. 잘 설계된 SQLite와 EXT4 구성요소는 NAND 기반 저장 장치에서 함께 사용할 때 그들은 조정되지 않은 상호작용으로 인해 많은 작고, 동기화된 랜덤 쓰기 I/O를 일으키기 때문에 예기치 못한 효과를 가진다. 우리는 Android의 I/O 스택(DBMS, 파일시스템, 블록 장치 드라이버)을 철저히 분석했다. 우리는 SQLite의 다섯가지 저널 모드를 다섯가지 다른 파일시스템에 조합하는 방식으로 SQLite 명령의 블록 레벨 I/O 행동 패턴을 실험했다. 삽입 명령과 업데이트 명령에 대하여 메타데이터에 대한 빈번한 업데이트를 제거하고, EXT4의 저널을 별도의 스토리지로 이동시키고, 폴링기반 I/O를 사용함으로써 우리는 상당한 퍼포먼스 향상을 이루어냈다. F2FS 파일시스템에서 WAL 저널링 모드(SQLite), 그리고 우리의 개선의 혼합을 통해 우리는 SQLite 퍼포먼스의 300%를 향상시켰다. 

