---
title:  "Differentiating Cache Files for Fine-grain Management to Improve Mobile Performance and Lifetime
 번역"
excerpt:  "모바일 성능 및 수명 향상을 위한 세분화된 관리를 위한 캐시 파일 차별화 논문 번역"
categories:
  - Papers
tags:
  - [android, papers]
toc: true
toc_sticky: true
sidebar: 
  nav: "docs"
---

## 논문 번역
NosLab 연구생 활동 기간동안 읽은 논문을 번역했다. 저작권을 염려하여 그림은 삽입하지 않았다.   
원 논문은 [https://www.usenix.org/conference/hotstorage20/presentation/liang](https://www.usenix.org/conference/hotstorage20/presentation/liang) 에서 찾아볼 수 있다.  
저자는 Yu Liang 등이다. 

# 모바일 성능 및 수명 향상을 위한 세분화된 관리를 위한 캐시 파일 차별화
## Differentiating Cache Files for Fine-grain Management to Improve Mobile Performance and Lifetime

## Abstract
대부분의 안드로이드 어플리케이션은 너트워크에서 데이터를 다운로드 받아야 한다.
안드로이드 시스템은 재 접근시 성능 향상을 위해 임시적으로 이 데이터들을 캐시파일로 로컬 flash storage 영역에 저장한다.
예를들어, 페이스북을 두 시간동안 사용하는 것은 1.2GB의 캐시 파일을 생성한다. 
모든 캐시를 flash storage에 저장하는 것은 전체 I/O 성능에 부정적인 영향을 미치고, 모바일 flash storage의 수명을 줄인다.
이 논문에서, 우리는 전형적인 모바일 어플리케이션의 캐시 파일의 접근 특성을 분석했다.
우리의 관측은 캐시 파일의 접근 패턴이 어플리케이션 레벨과 파일 레벨에서 다르다는 것을 나타낸다.
기존에는 캐시 파일을 모두 동등하게 처리하는 반면, 이 논문에서는 캐시파일을 다음 세 가지로 분류한다: burn-after-reading, transient, long-living.
Fine-grain Cache File Management(FCFM) 프레임워크는 다른 캐시파일을 다르게 관리하여 성능과 모바일 시스템의 수명을 향상시키기 위한 프레임워크이다. 
YouTube를 활용한 검증은 FCFM이 모바일 장치들의 성능과 수명을 상당히 향상시키는 것을 보여준다.

## 1. Introduction
모바일 장치는 우리의 삶에서 점점 더 중요해지고있다.
2019년에는, 전 세계적으로 스마트폰 사용자가 30억명을 능가하며, 안드로이드 스마트폰이 판매량의 80%를 차지했다.
성능과 수명은 모바일 장치의 핵심 측정항목이다.
현재, 모바일 시스템은 어플리케이션에서 다운로드된 임시 데이터를 모두 캐시 파일로 flash storage에 저장한다.
예를 들어, Facebook은 2시간동안 1GB 보다 많은 데이터를 생성하고, 13000번의 write를 발생시킨다.
이런 많은 수의 write 는 flash storage의 수명에 피해를 가할 뿐 아니라, 모바일 시스템의 많은 I/O를 이끌어 내기 때문에 잠재적으로 성능을 저하시킨다.
따라서, 근본적인 질문은 모바일 장치에서 캐시 파일 관리를 향상할 수 있는지이다.  

flash storage에 캐시 파일을 저장하는 것의 장점은 다음과 같은 암묵적인 가정에 따른다: 캐시 파일은 오랜 시간동안 종종 다시 접근될 것이다.
이 논문에서 우리는 소셜 미디어, 지도 관련 어플리케이션, 게임, 비디오, 인터넷 브라우저 등의 널리 사용되는 10개의 모바일 어플리케이션의 캐시 파일 접근을 tracing 하여 이 가정을 시험한다.
그리고 우리는 수집한 trace를 read/write 양, 파일의 수, read 명령의 관점에서 분석했다.
우리의 관측은 캐시 파일이 다시 접근될 것이라는 가정이 많은 어플리케이션의 캐시파일에 해당하지 않는다는 것을 밝혀냈다. 
사실, 캐시 파일 접근의 특성은 각 어플리케이션, 각 파일마다 매우 다양하다.   

우리의 관측을 기반으로, 이 논문은 모바일 장치의 캐시파일이 모두 동등하게 취급되어서는 안된다고 주장한다.
이 논문은 캐시 파일을 차별화하고, 모바일 장치의 성능과 수명을 향상시키기 위한 Fine-grain Chache File Management(FCFM) 프레임워크를 제시한다.
FCFM은 캐시 파일을 구분하고 그들을 in-memory 파일시스템과 flash 파일시스템으로 각각 메인 메모리와 flash storage에 저장하기 위해 필터를 채택한다.
해당 필터는 캐시 파일을 접근 패턴에 따라 burn-after-reading(BAR), Transient, 그리고 Long-Living 의 세 가지 타입으로 분류한다.
FCFM은 BAR 파일과 Transient 파일을 in-memory 파일시스템을 이용하여 메인 메모리에 저장하고 메모리에 공간이 부족하면 버린다.
Long-living 파일은 재 접근의 속도를 향상시키기 위해 flash storage에 저장된다.  

우리는 제안하는 FCFM을 안드로이드에서 YouTube를 활용해서 검증했다.
FCFM은 RAMFS와 F2FS를 채택했다. 
실험 결과, 기존의 캐시 파일 관리에 비해 FCFM은 쓰기 양과 쓰기 수를 각각 93%, 65% 감소시켰다. 
논문에 대한 기여는 다음과 같다.   

 - 우리는 모바일 어플리케이션들의 캐시 파일 접근 패턴을 조사하고 기존의 캐시 파일 관리는 모바일 장치의 성능과 수명에 나쁜 영향을 끼칠 수 있음을 알아냈다;
 - 우리는 측정한 캐시 파일 접근 패턴을 활용해 모바일 장치의 성능과 수명을 최적화하기 위해 Fine-grain Cache File Management(FCFM)을 제시한다.
 - 우리는 안드로이드 시스템에서 기존의 방식에 대해 FCFM의 효율성을 검증한다 

## 2. Backgrounds
데이터 접근 성능은 모바일 장치에서 뉴스 피드를 나타내거나 비디오를 보는 것 같은 사용자 경험에 직접적으로 영향을 미치는 핵심 지표이다.
이런 데이터는 주로 두 가지 소스에서 온다: 네트워크 혹은 로컬 저장장치. 
서버와 달리(cache server를 제외하고), 대부분의 모바일 어플리케이션은 새로운 데이터(뉴스나 비디오 등)를 네트워크로 부터 다운로드 받는다.
네트워크에 따라 대역폭이 다르기 때문에, 예를 들어, Verizon 4G LTE 무선 광대역은 5~12Mbps(0.652~1.5MB/s) 사이의 다운로드 속도를 제공한다, 대부분의 어플리케이션은 전형적으로 네트워크를 통한 데이터 전송을 최소화하고 성능을 향상시키기 위해 모바일 장치에 다운로드 받은 임시 데이터를 캐시 파일로 저장한다.   

기존의 안드로이드 시스템은 그림 1에서 처럼 먼저 캐시 파일을 주 메모리에 저장하고, 이들을 flash storage에 write 한다.
어플리케이션이 메인 메모리에 위치한 캐시 파일의 페이지에 접근할 때, throughput은 25.6GB/s 까지 도달할 수 있다.
요청받은 페이지가 메모리에 존재하지 않으면, 읽기 요청은 flash storage로 전송된다. 
데이터 접근 대역폭은 랜덤 읽기와 순차 읽기가 각각 39.3 MB/s와 272.2MB/s로 메인 메모리에의 파일에 접근하는 것 보다 100배 느리다.    

모바일 장치의 다른 중요한 지표는 수명이다.
증가하는 메모리와 하드웨어 성능과 함께, 모바일 장치의 교체 주기 길이 또한 길증가되었다. 
모바일 장치에 널리 사용되는 NAND flash storage는 제한된 write/erase 주기를 겪는다.
이는 flash storage에 write 양을 줄임으로써 스마트폰의 수명을 늘리는 것은 중요하다.

## 3. Cache File Analysis
현존하는 파일시스템은 모든 캐시 파일이 동등하다는 암묵적 가정하에 캐시 파일을 관리하기 위해 같은 전략을 적용한다.
하지만, 이 논문은 캐시 파일에 대한 접근이 어플리케이션 레벨과 파일 레벨, 패턴 레벨에서 다르다는 것을 보여준다.  

소셜 미디어, 지도, 게임, 비디오, 브라우저를 포함한 열개의 주로 사용되는 어플리케이션이 안드로이드에서 캐시 파일을 구분하기 위해 사용되었다.
어플리케이션의 워크로드는 표 1에 나타난다.
비슷한 워크로드는 논문[11]에서 또한 사용되었다.  

모든 실험은 ARM Cortex-A72 CPU, 32GB 내부 flash memory, 3GM RAM을 탑재한 화웨이 P9 스마트폰에서 실행되었다.
해당 스마트폰은 안드로이드 7.0과 리눅스 커널 4.1.18 버전으로 실행된다.
우리는 안드로이드 커널 소스코드를 instrument 했고, 캐시 파일의 read, write, 생명주기, 파일 크기 정보를 얻기 위해 Android Debug Bridge(adb)를 사용했다. 
실시한 실험에서, 우리는 몇몇 예상치 못한 결과를 발견했다.  

우리는 flash storage의 캐시 파일의 read 와 write 정보를 block/blkcore.c의 submit_bio() 함수를 사용하여 trace했다. 
각 어플리케이션은 그들의 기본 캐시 폴더를 /data/packageName/cache 에 가지고 있고, 이는 어플리케이션별로 private 하다.
몇몇 어플리케이션은 캐시 파일을 /media/0/Android/data/packageName/cache에 저장하는데, 이는 다른 어플리케이션에서 접근 가능하다.
우리는 read와 write 통계를 두 경로 모두에서 수집했다.  

### 3.1. Cache Access Patterns of Applications
우리는 다른 어플리케이션의 read 양과 write 양을 표 2에 요약했다. 
"Read"는 각 어플리케이션이 두 시간 동안 flash storage에 있는 캐시 파일을 읽은 양을 나타낸다.
"W/R"은 읽기 대비 쓰기 비율을 나타낸다.   

표 2에서, 각기 다른 어플리케이션에서의 read 양과 write 양은 상당한 차이를 보였다.
예를 들어, 소셜 미디어 어플리케이션들은 수백에서 수천의 캐시 파일 데이터를 wite한 반면, 게임 어플리케이션들은 오직 150MB 이하의 캐시 파일에 대한 접근을 했다.
동시에, 어플리케이션들은 또한 다른 Write/Read 비율을 나타낸다. 
예를 들어, YouTube의 W/R 비율은 크롬에 비해 34.1배로 나타난다.
종합하자면, 관측 결과는 아래와 같다: 
 - 관측 1. 다른 타입의 어플리케이션의 캐시 파일 접근은 총 데이터 양과 Wrtie/Read(W/R) 비율 측면에서 크게 다르다.  
다른 타입의 어플리케이션 간의 불일치는 어플리케이션의 본질적인 로직으로 결정된다.
예를 들어, 게임의 대부분의 데이터는 임시 데이터보다 고정된 데이터였다.
반대로, 소셜 미디어와 비디오 어플리케이션들의 대부분의 데이터는 네트워크에서 얻은 fresh information 이고, 이후에 이들은 재 접근을 가속화 하기 위해 캐시 파일로 취급되었다.   

관측 1은 우리가 어플리케이션의 고유 로직에 따른 캐시 파일에 대한 접근 패턴을 찾아낸다면, 모바일 장치의 캐시 파일을 신중하게 관리하는 방법으로 시스템 성능과 수명을 증가시킬 수 있음을 의미한다.  
 - 관측 2. 평균적으로, 캐시 파일의 write 양이 read 양 보다 100배가량 많다.  
관측 2는 대부분의 어플리케이션들이 그들의 캐시 파일을 드물게 재사용한다는 것을 밝혀냈다. 
이 경우, 드물게 사용되는 캐시 파일을 버림으로써 수명과 성능을 향상시킬 수 있는 커다란 가능성이 존재한다. 
더 나은 캐시 파일의 관리 시스템을 만들기 위해, 우리는 파일 레벨의 캐시 파일 특성을 더 활용해야 한다.

### 3.2. Cache-File Charactereistics
우리는 다음 세 가지 관점으로 캐시 파일의 특성을 분석했다: 파일 접근의 양, 캐시 파일의 수명, 파일의 크기.
각 어플리케이션의 캐시 파일 읽기 쓰기 양의 CDF(누적 분포 함수)는 각각 그림 2a와 2b에 나타난다.
캐시 파일을 그들의 read/write 양에 따라 정렬했다. 
 - 관측 3. 대부분의 어플리케이션에서의 read는 적은 몇개의 캐시 파일과 연관되어 있다.
관측 3에 따라, 드물게 다시 접근하는 대부분의 캐시 파일을 버림으로 flash storage에 쓰기 양을 줄이는 것은 유익하다.
하지만, 드물지만 다시 접근되는 큰 파일들이 있을 수 있다.
이런 파일들을 단순하게 삭제한다고 가정하면, read 요청을 만족하기 위해 파일을 검색하고 네트워크를 통해 다시 다운로드 해야하기 때문에, 이는 시스템 성능을 저하할 수 있다.
그러므로, 우리는 read 양과 파일의 수명, 캐시 파일 크기를 더 활용해야 한다.   

파일의 수명은 파일이 삭제되는 시간에서 생성된 시간을 빼는 방법으로 계산되었다.
어플리케이션에서 수집한 정보는 그림 2에서 나타난다.
히스토그램은 같은 수명을 가진 파일의 수를 나타낸다.
히스토그램 위의 숫자는 캐시 파일들의 read 양이다.
라인 차트는 같은 수명을 가진 캐시 파일들의 크기를 나타낸다.
캐시 파일의 수명을 조사하기 위해, 어플리케이션은 데이터가 수집되기 전까지 몇일동안 매일 사용되었다.
2시간 동안만 실험을 진행해서, 지난 며칠 동안 모든 긴 수명(2시간 이상) 캐시 파일이 생성된 반면 실험 중에는 다른 파일이 생성되었다.  

그림 2 (b)-(k)에서 보이는 바와 같이 CandyCrush와 Google Map 을 제외하고, 어플리케이션들은 캐시파일의 50% 이상을 적어도 하루 이상을 저장한다.
한편, 푸른 선은 수명이 긴 캐시 파일들 또한 이 어플리케이션들의 캐시 파일의 50 %를 차지함을 나타낸다.
게다가, YouTube와 CandyCrush를 제외하고, 어플리케이션에서 90% 이상의 read 양은 하루 이상 저장된 캐시 파일에 집중된다.
요약하여, 아래와 같은 관측 결과를 낸다.
 - 관측 4. 대부분의 어플리케이션에서, 대부분의 read는 수명이 긴 캐시파일에서 발생한다. 게다가, 이 파일들의 전체 크기는 전체 캐시 파일의 50% 이상이다.  
관측 4에 따르면, 짧은 수명을 가진 캐시파일은 삭제하고, 수명이 긴 캐시파일은 flash storage에 저장한다고 가정하면, 적은 performance cost로 flash storage에 write를 반으로 줄일 수 있다. 
만일 수명이 긴 캐시 파일이 read 될 때 메모리에 남아있다면, 접근 성능은 더욱 더 향상 될 것이다.
메모리에 넣을 캐시 파일을 고르는 것은 그들의 read 패턴이 고려되어야 함으로, 우리는 캐시 파일의 read 패턴을 활용한다.

### 3.3. Read Patterns of Cache Files
read 집약적인 파일의 read 패턴을 보기 위해, 우리는 캐시 파일을 그들의 read 양에 따라 정렬했다.
그림 3은 각 어플리케이션에서 가장 read가 많이 일어나는 10개의 캐시 파일의 read 패턴을 나타내고, 각 어플리케이션에서 선택된 캐시 파일은 10개의 색깔로 나타냈다.
단일 파일에서 많은 read 명령이 짧은 시간의 주기에 일어날 수 있음으로, 우리는 파일의 read 수를 80초마다 합쳤다.
더 큰 원은 이 주기에서 더 많은 read가 일어남을 나타낸다. 
각 프레임은 하나의 어플리케이션을 의미한다.
그림 3을 기반으로, 우리는 다음과 같이 관측했다:
 - 관측 5. 시간적 관점으로, 캐시 파일은 기본적으로 두 가지의 read 패턴으로 나뉜다: 짧은 시간 주기에 집약적으로 read가 일어나는 파일과 어플리케이션의 실행 시간에 걸쳐 연속적으로 read가 일어나는 파일. 

Zombie의 파일 0과 같이 집약적으로 read가 일어나는 캐시 파일의 경우, 시스템이 메모리에 캐시파일의 데이터를 유지한다고 가정하면 많은 I/O 명령을 제거함으로 시스템 성능을 향상시킬 수 있다. 
Twitter와 Google Map의 파일 0과 같이 어플리케이션 실행 시간 전반에 걸쳐 흩어진 read 가 일어나는 파일의 경우, 접근 시간의 간격이 수백 초이기 때문에 메모리에 저장할 필요가 없다.  

요약하면, 우리는 어플리케이션 레벨, 파일 레벨, 읽기 패턴에서 모든 캐시 파일이 동등하지 않다는 것을 나타냈다. 
하지만, 기존의 안드로이드 시스템은 캐시 파일의 다양한 특성을 알지 못하고 모든 캐시 파일을 로컬 저장소에 저장한다.
이는 시스템의 성능을 저하할 뿐 아니라, 모바일 장치의 수명에도 영향이 간다. 
우리는 캐시 파일을 메모리와 flash storage에 저장하여 성능과 수명을 향상시킬 필요가 있다고 생각한다. 
게다가 어플리케이션별 및 파일별 접근 패턴을 활용하기 위해 캐시 파일 관리를 재고해야 할 필요가 있다.

## 4. Fine-grain Cache File Management 
관측을 기반으로, 우리는 캐시 파일의 특성을 사용하여 모바일 장치의 수명과 성능을 향상시키기 위해 Fine-grain Cache File Management(FCFM) 프레임워크를 제시한다.
기존의 방법과 다르게, FCFM은 캐시 파일을 메모리와 저장소 둘 모두에 저장한다.
flash storage를 위한 flash 파일시스템은 따로 두고, FCFM은 메모리의 캐시 파일을 관리하기 위해 RAMFS나 TMPFS와 같은 in-memory 파일시스템을 사용한다.
flash 파일시스템에 속하는 캐시 파일은 flash storage에 쓰이는 반면, in-memory 파일시스템에 쓰이는 메모리는 삭제될 것이다. 
따라서 캐시 파일을 둘 중 어디에 둘지 결정하는 것은 중요하다.  

우리는 캐시 파일의 특성을 활용해 그들의 위치를 결정할 필터를 제시한다.
제안하는 필터는 캐시 파일을 다음 세 가지 카테고리로 나눈다: 
 - Burn-After-Reading(BAR)
 큰 용량을 가지지만 read 양이 적은 캐시 파일이다. 
 어플리케이션이 BAR 캐시파일을 닫을 때, 시스템은 즉시 해당 파일을 삭제한다, 다시말해 in-memory 파일시스템에서 캐시를 삭제한다.
 만일 어플리케이션이 해당 파일에 다시 접근하려 시도하면, 어플리케이션은 그 파일을 네트워크를 통해 다시 다운로드 해야 한다.
 BAR 파일의 read 양이 적기 때문에, 파일을 삭제하는 것은 성능에 영향을 미치지 않을 것으로 예상된다.  

 - Transient
 큰 용량을 가지고 많은 양의 read가 짧은 활동 주기에 일어나는 되는 캐시 파일이다.
 FCFM은 transient 캐시 파일 또한 in-memory 파일시스템을 통해 메모리에 저장한다. 
 메모리의 공간이 없는 경우, 시스템은 BAR 파일을 먼저 삭제하고, 이후 transient 파일을 LRU 알고리즘을 통해 삭제한다. 
 LRU를 통해 transient 파일을 삭제하는 것은 성능에 무시해도 좋을 정도의 피해를 가할 것으로 예상되는데, 이미 그들의 활동 주기가 지났기 때문이다.

 - Long-living
 나머지 캐시 파일이고, 특히 이들은 많은 양과 긴 활동 주기를 가진다.
 long-living을 flash storage에 저장하는 것은 네트워크를 통해 이들을 다시 fetching 하는데 많은 cost를 사용하는 것을 피할 수 있게 한다.  
 
section 3의 관측 2와 3에 따라, 시스템이 캐시 파일을 저장하기 위해 해당 필터를 사용하면, 오로지 long-living 캐시 파일만 flash storage에 write 하기 때문에 상당한 모바일 장치의 수명 개선이 예상된다.
게다가, BAR 파일과 Transient 파일이 메모리에서 직접 접근하기 때문에 시스템 성능 또한 향상될 것이다.   

## 5 Evaluation and Analysis
이번 단락에서는, 우리는 FCFM이 사용 가능하며, 효과가 있는지 검증하기 위해 YouTube에서 실험을 수행했다.
실험에서, 우리는 RAMFS와 F2FS를 in-memory 파일시스템과 flash 파일 시스템으로 각각 사용했다.  

우리는 YouTube 캐시 파일에 대한 데이터 접근 정보를 수집했다.
비디오 캐시 파일이 YouTube 전체 캐시파일의 93%를 차지했다.
따라서, 우리는 이 캐시파일을 실험의 타겟 파일로 지정했다.
우리는 비디오 대부분의 캐시 파일, 98% 정도가 flash storage에 write 되고 난 후, 절대 다시 read 되지 않는다는 것을 발견했다. 
정의한 세 카테고리에 따라, 필터는 비디오 캐시 파일을 BAR 파일로 간주했다.
우리는 FCFM을 두 가지 기준으로 비교했다: 1)Fully-in-memory: 타겟 캐시 파일을 RAMFS에 저장하는 것; 2)Fully-in-flash: 모든 캐시 파일을 flash storage에 저장하는 기존 안드로이드 관리자.
fully-in-memory의 경우를 구현하기 위해 /cache/exo 경로에 RAMFS를 마운트했다.
검증 결과는 표 3에 나타난다.  

결과는 FCFM이 flash storage에 쓴 캐시 파일의 양이 fully-in-memory와 fully-in-flash에 비해 각각 66%와 93% 더 적게 나타났다.
fully-in-memory의 전체 write 양은 fully-in-storage 보다 79% 더 적었는데, 목표 파일이 flash storage에 다시 쓰여지지 않고 메모리에 저장되었기 때문이다.
하지만, 메모리 공간을 차지하는 것은 다른 어플리케이션들이 작은 메모리 공간을 사용하게 만들었고, 따라서 추가적인 evict 작업으로 인해 flash storage 에 write 명령의 양이 15% 증가한다.
flash storage에 대한 write 명령의 수는 FCFM이 fully-in-memory와 fully-in-storage에 비해 각각 65%와 70% 적게 일어났는데, 이는 목표 캐시 파일이 제거되었기 때문이다. 
다시 말해, FCFM은 flash storage에 대한 write 명령의 수를 크게 줄일 수 있다.   

캐시 파일을 flash storage에 write 하는 것은 다른 사용자 I/O와 경쟁할 수 있고, 따라서 모바일 장치의 I/O 성능을 낮출 수 있다. 
게다가, 쓰여진 데이터가 삭제되면, 여유 공간을 확보하기 위해 GC가 유발 될 것이고, 그러면 모바일 장치의 수명이 줄어들 것이다.
그러므로, 캐시 파일의 write 수와 양을 줄이는 것은 모바일 장치에게 매우 중요하다.  

특히, 2%의 비디오 캐시 데이터는 재사용 될 것이고, 네트워크에서 다시 다운로드 되어야하는데, 그들이 제거되었기 때문이다. 
게다가, 올바르지 않은 분류는 네트워크 대역폭을 사용해 삭제된 캐시 데이터를 가져와야 하기 때문에 추가적인 오버헤드(지연성, 배터리, 돈0)를 유발할 수 있다.
그러므로, FCFM의 손해는 분류의 정확성에 달려 있다.
만일 분류가 정확하면 손해는 매우 작다(2%의 캐시 데이터 재 다운로드).   

## 6. Conclusion
다운로드된 데이터의 재 접근 성능을 향상시키기 위해, 현재의 안드로이드 시스템은 어플리케이션을 위한 캐시 파일을 임시적으로 저장한다.
이 논문은 대표 어플리케이션의 파일 접근을 분석하고 추적하여 캐시파일에 대한 접근 패턴을 조사했다. 
분석을 기반으로, 우리는 모바일 시스템이 각 캐시 파일이 매우 다른 접근 패턴을 보여주기 때문에 캐시 파일들을 다르게 대해야 함을 관측했다.
그러므로, 우리는 캐시 파일의 접근 패턴에 따라 in-memory 파일시스템 혹은 flash 파일시스템에 제대로 배치하기 위한 Fine-grain Cache File Management(FCFM) 프레임워크를 제시한다.
evaluation 결과는 FCFM이 모바일 장치의 수명과 성능을 상당히 증가시킬 수 있음을 보여주었다.  

## 7. Discussion Topics
제시한 FCFM 프레임워크는 논의되어야 할 세 가지 주요 과제를 가진다.   

 - Topic 1: 캐시 파일을 어떻게 조직적으로 분류할 것인가.
 FCFM에서 모든 캐시 파일은 그들의 특성에 따라 세 가지로 분류되어야 한다(read, write, file sizem, lifetime).
 캐시 파일이 다운로드 될 때, 시스템은 정확한 특성을 알 수 없다.
 한 가지 방법은, 확장자를 기반으로 캐시 파일 유형을 분석하는 것이다.
 예를 들어, 우리는 YouTube에서 제공하는 .exo 파일이 주로 오랜 수명(하루 이상)을 가지며, 다시 사용되지 않는 것을 확인했다.
 이 타입의 파일은 BAR 클래스로 분류될 수 있다.
 지도 어플리케이션에서 제공하는 .db 파일은 주로 긴 수명(하루 이상)을 가지며, 많은 read가 발생한다.
 게다가, read 명령은 시간에 걸쳐 드문드문하게 일어난다.
 이 타입의 파일은 storage 에 저장할 수 있다.  

 - Topic 2: RAM 용량은 in-memory 파일시스템에 얼마나 할당되어야 하는가.
 in-memory 파일시스템의 RAM 크기와 전체 성능 사이에 균형이 필요하다.
 in-memory 파일시스템의 RAM 용량이 커지면 더 많은 캐시 파일을 저장할 수 있어 캐시 파일 접근 성능을 향상 시킬 수 있다.
 반면, in-memory 파일시스템은 어플리케이션들과 OS와 메모리를 경쟁한다. 
 더 큰 in-memory 파일시스템은 전체적인 모바일 장치의 성능을 저하할 것이다.
 게다가, 캐시파일의 양은 각 어플리케이션마다 다르다.
 예를 들어, YouTube는 exo 폴더에 250MB의 한계를 설정한다.
 시스템은 in-memory 파일 시스템의 이 어플리케이션들을 위해 최대 크기를 설정할 수 있다.
 반면, Facebook 과 같은 다른 어플리케이션들은, 캐시파일이 한계 없이 증가한다.
 그러므로, 몇몇 파일은 in-memory 파일 시스템이 가득 차면 제거될 것이다.   

 - Topic 3: 캐시 파일 제거 전략
 LRU 기반의 제거는 현재 안드로이드 시스템에 사용되고 있다.
 하지만, page 기반의 제거는 캐시 파일 제거에 적합하지 않은데, 이는 하나의 파일의 하나의 페이지가 제거되면 전체 파일이 invalid 해지기 때문이다. 
 파일 기반의 제거 방식은 in-memory 파일 시스템에서의 삭제에 더 적합할 것이다.
 파일 기반의 제거 방식은 read 패턴, 파일 크기, 파일의 수명을 고려할 필요가 있다.   
