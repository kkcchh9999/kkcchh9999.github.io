---
title:  "Device_Specific Linux Kernel Optimization for Android Smartphones 번역"
excerpt:  "안드로이드 스마트폰을 위한 특정 장치 리눅스 커널 최적화"
categories:
  - Papers
tags:
  - [android, papers]
toc: true
toc_sticky: true
sidebar: 
  nav: "docs"
---

## 논문 번역
NosLab 연구원 활동 기간동안 읽은 논문을 번역했다. 저작권을 염려하여 그림은 삽입하지 않았다.   
원 논문은 [https://ieeexplore.ieee.org/document/8350440](https://ieeexplore.ieee.org/document/8350440) 에서 찾아볼 수 있다.  
저자는 Pengfei Yuan 등이다. 

# 안드로이드 스마트폰을 위한 특정 장치 리눅스 커널 최적화
## Device_Specific Linux Kernel Optimization for Android Smartphones

## Abstract
스마트폰을 더 강력하게 만들기 위해, 연구자들은 모바일 시스템과 어플리케이션 성능을 향상시키기 위한 많은 기술을 제안했다.
가장 인기있는 모바일 OS인 안드로이드는 리눅스 커널을 기반으로 만들어 져 있다. 
그러므로, 커널 성능을 최적화 하는 것은 잠재적으로 안드로이드 스마트폰의 성능을 향상시킬 수 있다.  

이 논문에서는, 안드로이드 스마트폰의 장치별 리눅스 커널의 구성을 최적화하는 컴파일러 기반의 접근을 제안한다.
장치의 런타임 feedback을 활용하는 것으로, 우리는 컴파일러가 profile 기반 최적화(Profile-Guided Optimization, PGO)하도록 지시할 수 있고, 특정 장치에 대한 리눅스 커널 이미지 최적화를 제공할 수 있다. 이 이미지는 제조 시 장치와 함께 제공되거나, 나중에 전체 시스템 업데이트에서 릴리즈 될 수 있다.
우리가 아는 한, 이 논문은 성능 향상을 위해 PGO를 안드로이드 스마트폰의 리눅스 커널에 성공적으로 적용한 최초의 연구이다.   

우리는 다른 세 가지의 안드로이드 스마트폰에서 실험을 진행했다: Nexus 5X, Nexus 6, Nexus 5.
결과적으로 각각 평균적인 성능이 11.1%, 4.1%, 9.3% 상승하였다. 
특히, 우리는 멀티쓰레드, 스케줄링, 바인더, 스토리지와 파일시스템 같은 핵심 안드로이드 시스템 컴포넌트의 성능 향상을 관측했다.

## 1. Introduction
스마트폰의 빠른 확산은 모바일 컴퓨팅의 번영을 이뤘다. 
장치의 크기와 배터리 제약으로 인해, 스마트폰의 연산 능력은 데스크탑이나 서버에 비해 아직 제한되어 있다.
더 정교한 어플리케이션을 지원하기 위해, COMET나 Uniport같은 모바일 클라우드 컴퓨팅 기술이 제안되어 강력한 클라우딩 컴퓨팅 인프라를 모바일 장치에 통합했다.
반면, 많은 연구들은 모바일 시스템과 어플리케이션의 성능 최적화를 수행한다.
예를 들어, F2FS는 플래시 스토리지를 위한 파일 시스템 성능을 향상시킨다.
SmartIO는 스마트폰의 iowait 지연을 줄인다. 
PerfChecker는 스마트폰 어플리케이션의 성능 버그를 탐지한다.   

모바일 OS의 가장 높은 점유율을 가지는 안드로이드는 리눅스 커널 기반이다. 
커널 성능은 전체 시스템 효율에서 중요하기 때문에, 리눅스 커널의 성능 최적화는 그 위에서 동작하는 안드로이드 어플리케이션을 가속할 수 있다.
이 논문에서, 우리는 안드로이드 모바일 장치를 위한 기기별 리눅스 커널 최적화를 위해 컴파일러 기반의 접근 즉, PGO를 채택했다.
최적화된 커널을 사용함으로, 우리는 멀티쓰레드, 태스크 스케줄링, 바인더 인터 프로세스 통신, 스토리지와 파일입출력 등의 중요한 안드로이드 시스템 컴포넌트의 성능을 향상시킬 수 있다.   

우리의 이전 연구는 PGO 기술을 사용해 리눅스 커널을 최적화 하는것이 x86 기반의 기기에서 실현 가능한 것을 증명했다. 
이 논문에서는, 우리는 성공적으로 PGO 기술을 안드로이드 스마트폰의 리눅스 커널에 적용했다. 
x86 기반 기기에서 수행한 어플리케이션별 커널 최적화와 다르게, 우리는 안드로이드 스마트폰을 위한 장치별 커널 최적화를 겨냥했다.    

장치별 최적화된 리눅스 커널은 새로운 혹은 기존의 장치에 대해 최적화 될 수 있다.
이는 새로운 장치가 제조될 때 함께 제공될 수 있다.
혹은 기존 장치에 대해, 시스템 업데이트시 제공될 수 있다.
instrumentation된 모바일 장치의 리눅스 커널을 실행 그리고 적절한 profile feedback을 수집함에 의해 우리는 컴파일러, 즉 GCC 에게 향상된 최적화를 수행하고, 각 장치에 최적화된 리눅스 커널 이미지를 생성하도록 지시할 수 있다.  

우리의 주요 기여는 아래와 같다.
 - 컴파일러 기반 접근을 통해 안드로이드 스마트폰을 위한 장치별 리눅스 커널 최적화를 제시한다. 실제 최적화 과정 동안, 유저는 커널에 대해 어떠한 수동적인 수정을 진행할 필요가 없다.
 - 우리는 제안된 최적화를 구현하고, 안드로이드 커널 성능을 측정했다. 세 가지 다른 안드로이드 스마트폰에서 우리의 실험을 기반으로 기본 -02 최적화와 비교했을 때, 우리의 접근은 시스템 성능을 4.1 ~ 11.1% 향상시켰다.
 - 우리가 아는 한, 이 논문은 가장 최초로 속도 향상을 위해 PGO 기술을 안드로이드 스마트폰의 리눅스 커널에 성공적으로 적용했다. 컴파일러 기반의 접근이기 때문에, 다른 안드로이드 시컴퓨터 공학 트레이스스템 향상 기법에서도 추가적인 성능향상을 위해 해당 기법을 적용할 수 있다.  

이하의 논문은 다음과 같은 순서를 가진다.
Section 2에서는 리눅스 커널을 최적화 하기 위한 PGO와 GCC 최적화에 대한 배경 지식을 다룬다.
Section 3에서는 안드로이드의 리눅스 커널에 대한 상세한 디자인과 구현에 대해 다룬다.
Section 4는 벤치마크와 실험 환경, 다른 스마트폰에서의 실험 결과에 대해 나타낸다.
Section 5는 관련 연구를, Section 6은 결론을 나타낸다.

## 2. Background
### 2.1 Profile-Guided Optimization (PGO)
PGO는 컴파일러 커뮤니티에서 잘 연구되었다. 
제어 흐름 그래프나 하나 이상의 프로그램 실행에서 수집된 표현 값 profile 등의 feedback information을 사용함으로 컴파일러는 자주 실행되는 부분의 최적화에 집중할 수 있다.
PGO는 FireFox, Chrome, GCC itself 같은 대형 오픈소스 프로젝트에 적용되어있고, 5~17% 의 속도 향상을 성취했다.  

전형적인 PGO 프로세스는 다음과 같은 절차를 따른다: 
 - Instrumentation. 컴파일러는 컴파일 중에 profile 정보를 모으기 위해 목표 프로그램을 instrumentation하고, 이는 이후에 최적화에 사용된다. 해당 profile 정보는 제어 흐름 트레이스, 값, 주소 profile 등을 포함한다.  

 - Profile Collection. instrumentation된 목표 프로그램은 profile 정보를 모으기 위해 실행된다. 실행 프로세스는 실제 실행 시나리오를 반영해야 한다.  

 - Optimization. 컴파일러는 목표 프로그램을 최적화 하기 위해 이전 단계에서 수집된 profile 정보를 사용한다. profile 정보는 컴파일러가 branch prediction, basic block reordering, funtion inlining, loop unrolling 등에서 더 나은 결정을 할 수 있도록 돕는다.  

최근 GCC 버전들은 샘플링 기반의 AutoFDO를 지원하고, 이는 프로그램 instrumentation이 필요하지 않다.
이는 인텔 프로세서의 last branch record support를 요구한다.
하지만, 안드로이드 스마트폰은 ARM 프로세서를 사용한다.
따라서 우리는 본 논문에서 AutoFDO를 채택하지 않았다. 

### 2.2 PGO in Linux Kernel
우리는 이전 연구에서 PGO가 x86 기반의 장치(데스크톱이나 서버 등)의 리눅스 커널에 적용할 수 있음을 보여줬고, 그 목표는 어플리케이션별 리눅스 커널 최적화였다. 
목표 어플리케이션이 실행될 때 리눅스 커널에서 instrumentation된 feedback 정보를 수집하고, 그 feedback 정보를 컴파일러 최적화에 사용함으로, 우리는 목표 어플리케이션에 비교적 최적의 성능을 제공하는 최적화된 커널 이미지를 빌드할 수 있었다.
PGO 기술을 리눅스 커널에 적용하기 위해 우리는 아래와 같은 도전을 극복했다: 
 - Enabling kernel instrumentation: 우리는 kernel instrumentation support를 리눅스 커널과 GCC에 추가했고, instrumentation된 커널이 x86 기반의 장치에서 동작할 수 있도록 했다.
 - Collecting kernel profile feedback: 우리는 커널 profile feedback을 수집하고 처리하기 위한 도구를 구현했다. 시작과 종료를 적절히 지정함으로 어플리케이션별 커널 feedback 정보를 수집할 수 있었다. 
 - Choosing correct optimization: 우리는 성능을 향상시키고 코드 길이를 줄이며 신뢰할 수 있게 커널 최적화를 하기 위한 적합한 컴파일러 최적화 옵션을 선택했다.

## 3. Design and Implementation
### 3.1 Challenges
유저 어플리케이션에서 PGO를 사용하는 것은 몇몇 컴파일러 옵션을 활성화하는 것 만큼 쉽고, x86 기반의 장치의 리눅스 커널에서 PGO를 적용하는 것은 이전 연구에서 구현되었고, 안드로이드 스마트폰을 위한 장치별 최적화된 커널을 구현하기 위해 PGO를 채택하는 것은 다음과 같은 새로운 기술적 과제에 직면하게 된다: 
 - Kernel instrumentation: 안드로이드 스마트폰은 일반적으로 레거시 리눅스 버전을 사용한다. 따라서, 우리는 kernel instrumentation support를 backport하고, 안드로이드에서 사용되는 ARM과 ARM64 프로세서 지원을 추가할 필요가 있다.
 - Booting the instrument kernel: 안드로이드의 부팅 절차는 복잡하고, 안드로이드 부트로더는 독점적이기 때문에, instrumentation된 커널의 부팅 문제를 해결하기 위해 블랙박스 테스트 및 리버스 엔지니어링을 수행해야 한다. 
 - Device-specific optimization: 장치별 커널 최적화를 성취하기 위해서, 우리는 먼저 장치별 커널 feedback 정보를 수집해야 한다. 후에, 우리는 안드로이드 스마트폰의 리눅스 커널을 최적화 시키기에 적합한 컴파일러 최적화 옵션을 선택해야 한다.

### 3.2 Design Overview
이전 연구에서, 우리는 성공적으로 PGO를 x86 기반 장치의 리눅스 커널에 적용했다.
PGO를 리눅스 ARM/ARM64 기반 안드로이드 스마트폰의 커널에 적용하기 위해서, 우리는 사용자 어플리케이션과 x86 기반 장치의 리눅스 커널에 PGO를 적용하는것과 비교하여 제안하는 접근법을 그림 1에 나타낸다.  

안드로이드 스마트폰에서 커널 instrumentation하기 위해서는, 우리는 관련된 커널 수정사항을 레거시 리눅스 버전으로 backport 하고, 다른 장치에 대해 instrumented된 커널 이미지를 빌드해야한다.
커널 profile feedback을 수집하기 위해서, 우리는 instrumented 커널을 장치에서 부팅하고, 적절한 툴을 통해 장치별 feedback 정보를 수집하고 처리할 필요가 있다.
커널 최적화를 위해, 우리는 안드로이드 시스템의 리눅스 커널을 위한 컴파일러 최적화 옵션을 채택해야한다.

### 3.3 Kernel Instrumentation
레거시 리눅스 버전에 대한 커널 instrucmentation support 의 backport는 다음과 같이 구성된다. 
 - Udate of the Linux gcov subsystem: gcov 서브시스템은 GCC에서 PGO 기술에 요구하는 제어 흐름 계측을 제공한다. 하지만, 레거시 리눅스 버전은 오직 2011년에 출시된 GCC 4.6 이하의 버전만 지원한다. 우리는 관련된 커널 패치를 backport하고, 최신의 GCC 버전을 지원하도록 gocv 서브시스템을 업데이트한다.
 - Support of ARM and ARM64 architecture: 우리는 안드로이드에서 주로 사용되는 ARM, ARM64의 커널이 instrumenting을 지원하도록 커널 빌드 시스템을 수정한다.
 - Support of data flow instrumentation: 제어 흐름 계측 외에도  GCC의 PGO 기술은 또한 대상 프로그램의 데이터 흐름 계측을 필요로 한다. 우리는 해당 부분을 구현하기 위한 논의를 이전 연구에서 진행했다. 
 - Fixing compilation errors: 안드로이드 스마트폰의 리눅스 버전이 일반적으로 오래되었기 때문에, 커널을 빌드할 때 컴파일 에러가 발생한다. ARM의 경우, `inline` 키워드에서 오류들이 발생할 수 있다. ARM64에서는, GCC의 내장 함수에 관한 에러가 발생할 수 있다. 우리는 이런 에러를 해결하기 위해 커널 소스코드를 수정한다.  

우리가 backporting을 위해 우리가 수정한 소스코드의 수를 요약하여 표 1에서 나타낸다.  

### 3.4 Booting the Instrument Kernel for Profile Collection
안드로이드 스마트폰에서 발생한 커널 feedback 정보를 수집하기 위해서, 우리는 먼저 instrumented 커널을 부팅해야한다.
ARM/ARM64 기반 안드로이드 장치의 부팅 과정은 아래와 같이 요약 가능하다. 
 1. 프로세서가 전원이 공급되고, BootROM에 저장된 주요 부트로더가 실행된다.
 2. BootROM의 공간이 한정적이기 때문에, eMMC에 저장되고 ARM TrustZone를 초기화하는 두 번째 부트로더가 로드되고 실행된다. 
 3. 실제 안드로이드 부트로더는 fastboot 기능을 제공하며, 로드되었고 실행된다.
 4. 리눅스 커널 이미지와 init 램디스크가 로드되고, 안드로이드 시스템이 실행된다. 

안전한 부팅을 보장하기 위해, 각 단계에서 다음 단계에서 로드된 콘텐츠의 전자 서명을 확인한다.
instrumented 커널을 부팅하기 위해, 우리는 커널 이미지를 로드하는 역할을 하는 안드로이드 부트로더를 다루어야 한다.
`fastbooting oem unlock` 명령을 실행함으로써, 우리는 안드로이드 부트로더를 언락하고, 서명 확인을 비활성화한다.
그러면, 우리는 커스텀된 커널 이미지를 장치에서 실행할 수 있게 된다.   

그러나, instrumented 커널은 보통 다른 매개변수로 인해 부팅을 실패하는데, 이는 이미지가 `-O2` 혹은 `Os`로 컴파일된 일반적인 커널 이미지보다 너무 크기 때문이다.
우리는 시행 착오를 통해 파라미터를 조정하고, 적절한 값을 결정 할 필요가 있다.  

블랙 박스 테스트 절차를 보조하기 위해, 우리는 `dd`커맨드를 사용하여 장치의 `aboot` 파티션에서 추출할 수 있는 안드로이드 부트로더에서 리버스 엔지니어링 분석을 수행할 수 있다.
리버스 엔지니어링 분석을 간단히 하기 위해, 대부분의 안드로이드 부트로더가 기반으로 하고 있는 LittleKernel의 소스코드를 인용할 수 있다.  

몇몇 장치들은 파라미터 값이 안드로이드 부트로더에 내장되어 있고, 명령어로 지정될 수 없다.
이런 경우, 우리는 instrumented 커널 이미지 크기를 장치에서 부팅할 수 있을 정도로 줄일 필요가 있다. 
구체적으로, 우리는 선택적 커널 instrumetnation을 채택했다.
리눅스 커널의 핵심 구성 요소만 instrumenting함으로써 스케줄러, 메모리 관리, 파일시스템, 바인더와 같은 이미지 크기를 크게 줄일 수 있었다.  

부팅 문제를 해결한 후, 우리는 instrumented 커널을 장치에서 실행할 수 있었고, feedback 정보를 수집했다.
profile 수집 도구는 쉘스크립트로 구성되어있다.
안드로이드 스마트폰에서 스크립트를 실행하기 위해, 우리는 Debian의 `busybox-static` 패키지를 사용했고, 이는 직접 안드로이드 스마트폰에서 실행할 수 있고, 쉘 스크립트의 실행을 지원하는 정적으로 연결된 ARM과 ARM64 바이너리를 제공한다.  

디바이스별 커널 최적화를 위한 profile feedback을 수집하기 위해, 우리는 instrumented 커널 위에서 실제 실행시간 시나리오를 반영한 안드로이드 어플리케이션 셋을 실행할 필요가 있다.
구체적으로, 우리는 Google Play 또는 기기의 앱 스토어에서 가장 인기있는 어플리케이션들을 선택할 수 있다.

### 3.5 Device-Specific Optimization
선택적인 instrumentation 커널을 사용하는 장치들을 위해서 수집된 feedback 정보는 완전하지 않다. 
feedback 정보가 다루지 않는 커널 소스코드를 위해, 우리는 profile feedback이 존재할 때만 이점이 있는 최적화 옵션을 사용할 수 없게 할 필요가 있다.
구체적으로, 우리는 `-fprofile-use`옵션을 `-fbranch-probabilities`옵션으로 대체할 수 있다.  

우리의 커널 최적화의 컴파일러 기반 접근법은 장치별로 다음과 같은 측면을 따른다: 
 - 다른 장치는 다른 리눅스 버전과 빌드 구성을 사용한다.
 - 다른 장치는 커널 최적화를 위해 다른 GCC 버전을 사용할 수 있다.
 - profiling 중에 수집된 feedback 정보는 장치별로 다르다. 이 feedback 정보는 profile-guided 커널 최적화에 사용된다. 
 - 커널 최적화에 사용된 상세한 컴파일러 옵션은 장치별로 다르다.

## 4. Evaluation
### 4.1 Benchmarks
안드로이드 스마트폰의 시스템 성능을 검증하기 위해서, 우리는 OS 기능을 집중적으로 호출하는 시스템 집약적 벤치마크를 사용해야 한다.
GeekBench 나 AnTuTu 같은 인기있는 벤치마크들은 연산 집약적이고, 따라서 우리의 검증에 부합하지 않는다.
그러므로 우리는 안드로이드 커널의멀티쓰레딩, 스케줄링, 바인더, 스토리지와 파일시스템과같은 핵심 안드로이드 시스템 컴포넌트의 성능을 측정하기 위해 벤치마크를 수집하고 구현했다.  

이전 연구는 안드로이드의 정확한 벤치마킹 성능을 측정하는것은 어렵다고 말한다.
성능 결과를 유효하고 안정적인지 확인하기 위해, 우리는 CPU 스케일링 관리자를 `performence`로 설정하고, 벤치마크의 CPU affinity를 설정하기 위해 `taskset` 명령을 사용하고, `thermal-engine` 이나 `mpdecision` 같은 성능 조절 서비스를 정지한다.

#### 4.1.1 MultiThreading and Task Scheduling
안드로이드 어플리케이션은 일반적으로 멀티쓰레드를 사용한다. 
메인 쓰레드는 UI 및 상호작용을 담당한다.
메인 쓰레드에서 시간을 소모하는 작업을 진행하는 것은 전체 어플리케이션을 정지 시킨다.
그러므로, 안드로이드 어플리케이션은 백그라운드 쓰레드에서 시간을 소모하는 작업을 진행할 때 `AsyncTask`, `HandlerThread`, `ThreadPoolExecutor`과 같은 API를 사용하게 한다.  

안드로이드 시스템의 멀티쓰레딩과 스케줄링 퍼포먼스를 측정하기 위해서, 우리는 반복적으로 아래의 명령을 수행하고 처리량을 측정하는 벤치마크 어플리케이션을 구현했다: 
 1. 벤치마킹 동시성에 따라 `java.lang.Thread` 인스턴스 집합을 생성
 2. `Thread` 인스턴스의 `start` 메소드를 호출
 3. 완료를 기다리기 위해 `Thread` 인스턴스의 `join` 메소드를 호출 '  

실행시간 중에, 각 쓰레드는 아래의 명령을 반복적으로 수행한다: 
 - 현재 쓰레드의 우선순위를 백그라운드 레벨로 설정하기 위해 `android.os.Process` 클래스의  `setThreadPriority` 메소드를 호출한다. 
 - CPU를 명시적으로 해제하고, 커널의 스케줄링을 발생시키기 위해 `Thread.yield` 메소드를 몇 차례 호출한다.  

#### 4.1.2 Binder IPC
바인더는 안드로이드 시스템의 핵심 컴포넌트이다. 이는 핵심 플랫폼의 프로세스에서 발생하는 거의 모든 작업에 사용된다.
`ActivityManager`, `WindowManager`, `PackageManager`, 안드로이드 어플리케이션의 컴포넌트 내부 통신과 같은 시스템 서비스들 모두 커널 모듈에서 지원하는 바인더 IPC를 사용한다.   

바인더 IPC 성능을 측정하기 위해, 우리는 두 개의 벤치마크 어플리케이션을 구현했다. 
하나는 백그라운드 서비스를 실행하고, 이 서비스는 `android.app.IntentService` 클래스를 기반으로 하고, 안드로이드 메니페스트 파일에 선언되어있다. 
다른 하나는 포그라운드에서 벤치마크 결과를 나타내기 위해 동작한다. 
두 어플리케이션은 그들 간의 바인더 IPC를 통해 의사소통한다. 
성능 측정 과정은 다음과 같다:
 1. 포그라운드 어플리케이션은 UI 버튼의 onClick 이벤트에 응답한다. 이는 `android.os.Messenger` 인스턴스를 `android.content.Intent`에 넣고, `android.content.Context` 클래스의 `startService` 메소드를 호출하여 백그라운드 서비스를 시작한다.
 2. 백그라운드 서비스는 `IntentService` 클래스의 `onHandleIntent` 이벤트에 반응하고, 현재 프로세스의 `Messenger` 인스턴스를 포그라운드 어플리케이션의 `Messenger` 인스턴스의 `send` 메소드를 통해 포그라운드 어플리케이션으로 보낸다.
 3. 포그라운드 어플리케이션은 `Messenger` 인스턴스에 바인딩되는 `android.os.Handler` 클래스의 `handleMessage` 이벤트에 응답하고, 백그라운드 서비스와 `Messenger` 인스턴스를 통해 의사소통한다. 이는 벤치마크 동시성에따라 여러 메세지를 동시에 보낸다.
 4. 백그라운드 서비스는 `Messenger` 인스턴스에 바인딩된 `Handler` 클래스의`handleMEssage` 이벤트에 응답하고, 포그라운드 어플리케이션과 `Messenger` 인스턴스로 의사소통한다. 
 5. 이전의 두 단계는 반복적으로 실행된다. 포그라운드 어플리케이션은 Binder IPC 처리량을 연산하고, 결과를 나타낸다. 

#### 4.1.3 Storage and File System
스토리지와 파일시스템은 매우 중요한 OS 컴포넌트이다. 
성능을 측정하기 위해, 우리는 SQLite를 선택했고, 이는 안드로이드 어플리케이션에서 벤치마크로 널리 사용되는 임베디드 데이터베이스다. 
우리가 사용한 어플리케이션은 `speedtest1`이고, 이는 SQLite의 공식 벤치마크 어플리케이션이다. 
우리는 ARM과 ARM64 버전을 크로스컴파일 해서 안드로이드 스마트폰에서 동작했다. 
테스트 로드 파라미터 `--size`는 20으로 설정하고, 테스트 데이터베이스 파일은 데이터 파티션에 들어간다.   

### 4.2 Devices and Experimental Setup
우리의 실험에서 사용된 안드로이드 스마트폰들은 Nexus 5X, Nexus 6, Nexus 5이고, 이들은 구글에서 공식적으로 발행되었다. 표 3은 그들의 상세정보를 나타낸다.  

Nexus 5X에 사용된 퀄컴의 스냅드래곤 808 프로세서는 ARMv8-A 64bit 명령어 셋 아키텍처를 채택했다.
프로세서는 6개의 코어를 가지고, 그 중 두 개는 1.82 GHz의 피크 주파수를 가지는 Cortex-A57 기반이고, 네 개는 1.44 GHz의 피크 주파수를 가지는 Cortex-A53을 기반으로 한다.
Nexus 5X를 위해 사용할 컴파일러는 GCC 6.4 ARM64 크로스 컴파일러이다. Cortex-A57 코어와 Coretex-A53 코어의 주파수가 상당히 다르기 때문에, 우리는 작업 명령을 사용하여 CPU affinity를 설정할 때 벤치마크를 같은 타입의 코어에서 실행하도록 명시했다.    

Nexus 6에 사용된 퀄컴 스냅드래곤 805 프로세서는 ARMv7-A 32-bit 명령어 셋 아키텍처를 채택했다.
이는 네 개의 2.7GHz의 피크 주파수를 가지는 Krait 450 코어를 가진다. 
Nexus 6에 사용한 컴파일러는 GCC 5.4 ARM 크로스 컴파일러를 사용했는데, GCC 6.4로 컴파일된 리눅스 커널과 -O3 가 Nexus 6에서 실행되지 않기 때문이다.  

Nexus 5에 사용된 퀄컴 스냅드래곤 800 프로세서 또한 ARMv7-A 32-bit 명령어 셋 아키텍처를 채택했다.
이는 네 개의 2.26GHz 피크 주파수를 가지는 Krait 400 코어를 가진다. 
Nexus 5에 사용한 컴파일러 또한 GCC 5.4 ARM 크로스 컴파일러이고, GCC 6.4로 컴파일된 리눅스 커널과 -Os 가 Nexus 5에서 실행되지 않기 때문이다.  

세 개의 휴대전화들은 LineageOS 14.1을 실행하고, 이는 안드로이드 7.1.2를 기반으로 하며, 유명한 CyanogenMod 프로젝트의 연속이다.
LineageOS를 설치하기 위해, 우리는 휴대전화를 위한 부트로더를 해제하고, TWRP 리커버리를 flash 한다.
성능 검증을 위해, 우리는 휴대폰들의 루트 권한을 획득하기 위한 LineageOS 의 `su` 애드온을 설치했다.  

세 휴대전화의 리눅스 커널 버전은 구버전이다.
Nexus 5X와 Nexus 6에 사용된 Linux 3.10은 2013년에 공개되었고, Nexus 5에 사용된 Linux 3.4는 2012년에 공개되었다.
이는 안드로이드 스마트폰에게 흔한 이슈이다.
왜냐하면 휴대전화의 몇몇 장치 드라이버는 소스 바이너리가 잠겨있고, 우리가 커널을 수동으로 업데이트 할 수 없기 때문이다.
우리가 사용한 커널 빌드 구성은 LineageOS에서 기본으로 제공되며, `lineageos_bullhead_defconfig`, `shanu_defconfig`, `lineageos_hammerhead_defconfig`가 각각 Nexus 5X, Nexus 6, Nexus 5에 상응하게 사용되었다.   

Nexus 5X의 경우, 우리는 부팅 파라미터 `kernel-offset`, `tags-offset`, `ramdisk-offset` 을 수정할 필요가 있었다. 이는 커널 이미지가 겹치는 걸 방지하고 램디스크를 물리적 주소공간에서 실행하고 instrumented 커널을 휴대전화에서 실행하기 위함이다.  

Nexus 6의 경우, 우리는 그것의 부팅 파라미터가 안드로이드 부트로더 내부에 구성되어 있음을 알아냈다.
그러므로 선택적으로 instrumentation을 진행해 instrumented 커널을 빌드하고, 컴파일러 옵션을 선택하여 최적화된 커널을 구축한다.  

Nexus 5의 경우, instrumented 커널을 전화기에서 부팅하기 위해 파라미터 `tags-offset` 과 `ramdisk-offset`의 값을 증가시키기만 하면 된다. 

### 4.3 Result and Analysis
우리는 -O2, -Os, -O3 및 PDO를 포함한 다양한 GCC 최적화 구성으로 컴파일된 커널을 사용하여 각 폰에 대해 서로 다른 벤치마크를 실행했다.
-O2가 기본 최적화 구성으로 사용되었기 때문에, 우리는 관련된 성능 수치를 -O2의 성능 결과에 대해 정규화된 상대적인 수치를 보여준다.
모든 "average" 수는 기하학적으로 연산된 수이다.   

#### 4.3.1 Nexus 5X
그림 2는 Nexus 5X의 실험 결과를 나타낸다. 
그림에서 쓰레드 1, 쓰레드 4는 각각 동시성이 1, 4로 설정된 멀티쓰레딩과 작업 스케줄링 벤치마크를 나타낸다.
같은 규칙은 바인더 IPC 벤치마크를 위한 IPC-1 과 IPC-4 에도 적용된다.  

우리는 PGO가 Binder IPC, 멀티쓰레딩, 태스크 스케줄링 퍼포먼스를 상당히 증가시키는 것을 볼 수 있다.
또한 SQLite의 성능도 향상시키는데, 이는 스토리지와 파일시스템 성능을 대표한다. 
쓰레드 1의 벤치마크의 경우, 속도가 17% 가량 향상되었다.
기하학적 의미의 평균으로, Nexus 5X의 시스템 성능은 11.1% 향상되었다.  

PGO 이외에, 우리는 -Os와 -O3으로 컴파일 된 리눅스 커널과도 성능을 비교했다. 
-O2와 비교했을 때, -O3은 성능을 향상시킨 반면, -Os은 모든 벤치마크에서 성능이 하락했다.
평균적인 성능은 -Os의 하락폭 5% 이며, -O3의 상승폭 2.5% 이다.  

#### 4.3.2 Nexus 6
그림 3은 Nexus 6의 실험 결과를 나타낸다. 
우리는 PGO가 멀티쓰레딩, 작업 스케줄링 성능을 크게 향상시키는 것을 볼 수 있다. 
또한 바인더 IPC와 SQLite 성능 또한 향상시켰다.
평균적으로, Nexus 6의 스템 성능은 4.1% 상승되었다.
Nexus 6의 속도 상승폭은 Nexus 5X 보다 상당히 낮은데, 이는 우리가 선택적인 instrumentation과 커널 최적화를 채택했기 때문이다.   

-O2와 비교하여 -Os, -O3은 몇몇 벤치마크에서 성능을 향상시켰고, 다른 벤치마크에서는 성능을 하락시켰다.
이는 세 가지 최적화 옵션이 모두 Nexus 6 에게는 최적의 선택이 아님을 보여준다.  

#### 4.3.3 Nexus 5
그림 4는 Nexus 5의 실험 결과를 나타낸다.
우리는 PGO가 Binder IPC, 멀티쓰레딩, 작업 스케줄링 성능을 크게 향상시키는 것을 볼 수 있다.
이는 또한 SQLite 성능을 향상시킨다. 
Thread-4 벤치마크의 경우, 속도가 약 20%까지 향상된다.
SQLite의 속도 향상은 주로 낮은데, 이는 eMMC 플래시 저장소의 I/O 명령을 가속할 수 없기 때문이다.
평균적으로, Nexus 5의 시스템 성능은 9.3% 향상되었고, 이는 Nexus 5X와 견줄 만 하고, Nexus 6보다 높은 수치이다.   

-O2와 비교하여, -Os는 시스템 성능을 평균적으로 1.5% 하락시켰고, -O3은 평균적으로 0.8% 향상시켰다.
몇몇 벤치마크에서, 다른 최적화 옵션이 더 잘 동작한다.
하지만 PGO가 항상 최고의 성능을 나타낸다.

### 4.4 Discussion
우리가 이전에 수행한 어플리케이션별 리눅스 커널 최적화 연구와 비교하여, 이번 연구는 스마트폰 같은 모바일 장치에서 장치별 커널 최적화를 이뤄 낼 수 있다.
특히, 제안된 접근법은 다음과 같은 이점을 가질 수 있다: 
 - 특정 장치에서 시스템 집약적인 어플리케이션을 실행하는 동안 instrumentation 기반의 profiling 을 통해 feedback 정보를 수집한다는 점에서 최적화는 장치별로 다르다.
 일반적인 PGO 의 원칙은 profile 에 기반을 두고있는데, 따라서 결과적으로 커널은 각 장치에서 수집된 profile에 따라 최적화 된다.  
 - 최적화 자체는 generic한데, 이는 PGO 기술 자체가 상대적으로 generic한 최적화 메커니즘이기 때문이다.
 어플리케이션별 profile과 함께라면, 어플리케이션별 최적화된 커널을 생성할 것이다.
 장치별 profile을 진행했기 때문에, 장치별로 최적화된 커널을 생성할 수 있다.
 - 이 최적화는 반 자동화 과정이 적용될 수 있다.
 우리는 자동화된 커널 패치와 profile 뿐만 아니라, GCC 최적화 또한 자동화할 수 있도록 툴 체인을 구성했다.
 전체 과정 중 사람이 개입해야하는 유일한 단계는 profile collection 단계이고, 이 때 사람은 장치를 재부팅하고 특정 벤치마크를 실행해야 한다.

우리의 연구는 또한 아래와 같은 제한점이 존재한다: 
 - 장치별 최적화된 커널을 생성하기 위해서, 우리는 profile 수집 단계에서 적절한 벤치마크를 실행해야 한다. 
 하지만 안드로이드 어플리케이션과 적합한 벤치마크가 존재하지 않는다. 
 사실, 널리 사용되는 안드로이드 벤치마크가 존재하지 않는다.
 이런 이유로, 우리는 우리 고유의 벤치마크 어플리케이션들을 구현하고 수집해야 했다.
 하지만, 우리는 사용된 어플리케이션이 벤치마크를 대표할 수 있는지 보장할 수 없다.
 만일 우리가 더 나은 벤치마크를 찾을 수 있다면, 이는 잠재적으로 더 나은 profile을 생성할 수 있고, 이를 통해 더 최적화된 커널을 생성할 수 있을 것이다. 
 - PGO를 수행하기 위해, 리눅스 커널의 패치가 선행되어야 한다.
 비록 우리가 자동화된 커널 패치를 구현했을지라도, 우리가 접촉한 몇몇 회사들은 여전히 어떻게 메인 커널과 패치된 커널 사이의 일관성을 유지할지 고민하고 있었다.
 우리가 이미 주 리눅스 커널에 수정사항을 통합하려고 시도했지만, 이는 어떠한 보장도 받지 못하는 긴 작업이 될 것이다. 
 - 리눅스 커널은 주로 -O2와 -Os를 통해 컴파일된다. 
 비록 우리가 -O3을 통해 더 공격적으로 최적화된 커널을 생성할 수 있음을 보여주었지만, 실제로는 널리 채택되거나 테스트되지 않는다. 
 PGO가 -O3에서 사용했던 공격적인 최적화의 일부를 적용했기 때문에, 강력한 커널이 생성될 것인지 아닌지가 우리의 주된 관심사 중 하나이다.
 우리는 우리의 향후 연구에서 이를 조사하려 시도할 것이다.   

## 5. Related Work
모바일 장치의 연산 능력을 향상하기 위해, 많은 연구들이 MMC 기술을 연구한다.
Uniport 같은 MMC 프레임워크는 모바일 어플리케이션의 수정과 재구현을 요청하는 반면 COMET 같은 MMC 시스템은 Dalvic 가상 머신과 같은 실행환경에서의 광범위한 수정과 구현을 필요로 한다. 
우리의 컴파일러 기반 접근은 모바일 장치의 성능 향상을 위해 OS 커널을 직접 최적화한다.
우리는 오직 기존의 커널 이미지를 장치별로 최적화된 커널 이미지로 변경하기만 하면 된다.
장치의 모바일 어플리케이션들은 상대적으로 최적의 성능을 가지게 될 것이다.  

모바일 시스템과 어플리케이션의 성능을 최적화하기 위한 탐색을 진행하는 다른 연구들이 있다. 
예를 들어, F2FS는 플래시 저장소의 성능을 향상시키는 새로운 파일 시스템이다. 
Smart I/O 는 `iowait` 딜레이를 줄이는 시스템이다.
PerfCheckr는 스마트폰 어플리케이션의 성능 버그를 탐지하는 도구이다.
이 연구들은 OS나 어플리케이션에서 수정 혹은 구현을 요구하지만 우리의 컴파일러 기반 접근은 최적화된 커널을 구성할 때 어떤 소스코드 수정도 필요가 없다.   

우리의 이전 연구는 주로 x86 기반의 장치들에서 어플리케이션별 커널 최적화에 집중했고, 이번 논문은 안드로이드 스마트폰의 장치별 커널 최적화에 중점을 둔다.
우리는 몇몇 기술적 문제를 성공적으로 극복하고 PGO 기술을 안드로이드 시스템의 리눅스 커널에 성공적으로 적용했다.  

## 6. Conclusion
우리는 안드로이드 스마트폰의 장치별로 최적화된 리눅스 커널을 구성하기 위해 PGO의 이점을 가진 컴파일러 기반의 접근을 제시했다. 
특히, 우리는 커널 instrumentation, instrumented 커널의 부팅 그리고 장치별 커널 최적화 문제를 해결했다.
성능 검증을 위해, 우리는 멀티쓰레딩, 작업 스케줄링, 바인더, 스토리지와 파일시스템과 같은 핵심 안드로이드 시스템 컴포넌트를 위한 벤치마크를 구현하고 수집했다.
실험 결과는 평균적인 시스템 성능을 Nexus 5X, Nexus 6, Nexus 5에서 각각 11.1%, 4.1%, 9.3% 향상시킴을 보여준다.
